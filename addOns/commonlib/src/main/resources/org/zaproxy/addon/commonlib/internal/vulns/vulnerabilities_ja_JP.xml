<?xml version="1.0" encoding="utf-8"?>
<vulnerabilities>

<vuln_items>wasc_1</vuln_items>
<vuln_item_wasc_1>
	<alert>不適切な認証</alert>
	<desc>不十分な認証は、Webサイトが攻撃者に対して適切な認証を行わずに機密性の高いコンテンツや機能へのアクセスを許可する場合に発生します。 Webベースの管理ツールは、機密性の高い機能へのアクセスを提供するWebサイトの良い例です。 特定のオンラインリソースによっては、これらのWebアプリケーションは、ユーザーの身元を適切に確認することなく直接アクセス可能であってはなりません。

認証の設定を回避するために、一部のリソースは特定の場所を「隠し」、その場所をメインのWebサイトや他の公開された場所にリンクを張らないことで保護されています。 ただし、このアプローチは「隠蔽によるセキュリティ (Security Through Obscurity)」に過ぎません。 攻撃者がリソースの場所を知らなくても、特定のURLを通じて直接アクセス可能であるということを理解することが重要です。 特定のURLは、一般的なファイルやディレクトリの場所 (例: /admin) に対するブルートフォース (総当たり) による探索、エラーメッセージ、リファラーログ、またはヘルプファイルなどのドキュメントを通じて発見される可能性があります。 コンテンツ主導型または機能主導型に関わらず、これらのリソースは適切に保護されるべきです。</desc>
	<solution>フェーズ: アーキテクチャと設計
OWASP ESAPI 認証機能などの認証フレームワークまたはライブラリを使用してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/287.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/284.html</reference>
</vuln_item_wasc_1>

<vuln_items>wasc_2</vuln_items>
<vuln_item_wasc_2>
	<alert>不適切な認可</alert>
	<desc>不適切な認可は、アプリケーションがユーザーがセキュリティポリシーに準拠した方法で機能を使用したり、データにアクセスしていることを確認するための適切な認可チェックを実行しない場合に発生します。 認可手続きは、ユーザー、サービス、またはアプリケーションが何を実行できるかを強制する必要があります。 ユーザーがWebサイトに認証されたとしても、必ずしもユーザーがすべてのコンテンツと機能に完全にアクセスできるべきであるとは限りません。

不十分な機能認可

多くのアプリケーションは、ユーザーごとに異なるアプリケーション機能を付与します。 例えば、ニュースサイトは、ユーザーがニュース記事を閲覧することは許可しますが、公開することは許可しません。 決済システムでは、お金を支払う人と受取とる人で権限が異なります。 不十分な機能認可は、アプリケーションがセキュリティポリシーに違反してユーザーがアプリケーション機能にアクセスすることを防げない場合に発生します。

非常に有名な例として、2005年のハーバード・ビジネス・スクールの出願プロセスへのハッキングがあります。 認可の不備により、ユーザーがアクセスを許可されるべきではないWebサイトの部分にアクセスし、自身のデータを閲覧することができました。
 
不十分なデータ認可

多くのアプリケーションは、URL内で基礎となるデータ識別子を公開します。 例えば、システム上の医療記録にアクセスする際、次のようなURLを持つ可能性があります：

https://example.com/RecordView?id=12345

アプリケーションが認証されたユーザーIDに読み取り権限があることをチェックしない場合、ユーザーが見るべきではないデータをユーザーに表示する可能性があります。

不十分なデータ認可は不十分な機能認可よりも一般的です。これは、プログラマーは一般的にアプリケーション機能について完全な知識を持っているが、アプリケーションがアクセスするすべてのデータの完全なマッピングを常に持っているわけではないためである。 プログラマーは機能認可のメカニズムを厳格に制御することが多いですが、データ認可についてはデータベースなどの他のシステムに頼っています。</desc>
	<solution>フェーズ: アーキテクチャと設計; オペレーション
権限の設定、管理、および取り扱いを非常に慎重に管理してください。 ソフトウェア内の信頼ゾーンを明示的に管理してください。

フェーズ: アーキテクチャと設計
システム設計に適切な区画化が組み込まれており、その区画化が特権分離機能を可能にし、さらに強化するために機能することを確認してください。 アーキテクトと設計者は、システム特権の使用と放棄の適切なタイミングを決定する際、最小権限の原則に従うべきである。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/284.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/285.html</reference>
</vuln_item_wasc_2>

<vuln_items>wasc_3</vuln_items>
<vuln_item_wasc_3>
	<alert>整数オーバーフロー</alert>
	<desc>整数オーバーフローは、乗算や加算などの算術演算の結果が、それを格納するために使用される整数型の最大サイズを超える場合に発生する状態です。 整数オーバーフローが発生すると、解釈される値は最大値を「ラップアラウンド (巡回)」し、最小値から再び開始したように見えます。これは、時計が13:00を1:00を指し示すのと似ています。

例えば、最も一般的なコンピューターアーキテクチャにおける8ビット符号付き整数の最大値は127、最小値は-128です。 プログラマーがそのような変数に値 127 を格納し、それに1を加算した場合、結果は128になるはずです。 しかし、この値はこの整数型の最大値を超えるため、解釈される値は「ラップアラウンド」して -128 になります。</desc>
	<solution>フェーズ: 要件
すべてのプロトコルが厳密に定義され、すべての範囲外動作が簡単に識別でき、プロトコルへの厳密な準拠を要求してください。

フェーズ: 要件
この脆弱性が発生しない言語を使用するか、この脆弱性を回避しやすくする構造を提供する言語を使用してください。
可能であれば、自動的な境界チェックを行う言語やコンパイラを選択してください。

フェーズ: アーキテクチャと設計
この脆弱性が発生しない、またはこの脆弱性を回避しやすくする構造を提供する、実績のあるライブラリやフレームワークを使用してください。
予期せぬ結果を招くことなく数値を扱いやすくするライブラリやフレームワークを使用してください。
例として、SafeInt (C++) や IntegerLib (CまたはC++) のような、安全な整数処理パッケージがあります。

フェーズ: 実装
数値入力が期待される範囲内にあることを確認することで、入力検証を実行してください。 入力が期待される範囲の最小要件と最大要件の両方を満たすように強制してください。
可能な場合は符号なし整数を使用してください。 これにより、整数オーバーフローの健全性チェックが容易になります。 符号付き整数を使用しなければならない場合は、範囲チェックに最小値と最大値の両方が含まれていることを確認してください。

フェーズ: 実装
プログラミング言語の基盤となる表現と、それが数値計算とどのように相互作用するかを理解してください (CWE-681)。 バイトサイズの不一致、精度、符号付き/符号なしの区別、切り捨て、型変換、キャスト、「非数 (not-a-number)」計算、および言語がその基盤となる表現に対して大きすぎる、または小さすぎる数値をどのように扱うかに細心の注意を払ってください。
また、32ビット、64ビット、および数値表現に影響を与える可能性のあるその他の違いにも注意を払ってください。

フェーズ: 実装
コンパイラの警告を注意深く調査し、符号付き/符号なしの不一致など、セキュリティ上重大な可能性のある問題を排除してください。 この脆弱性が悪用されることは稀であっても、一度の失敗がシステム全体の侵害につながる可能性があります。</solution>
	<reference>https://cwe.mitre.org/data/definitions/190.html</reference>
</vuln_item_wasc_3>

<vuln_items>wasc_4</vuln_items>
<vuln_item_wasc_4>
	<alert>不適切なトランスポート層保護</alert>
	<desc>トランスポート層の保護不足
トランスポート層の保護が不十分な場合、通信が信頼できない第三者に露出し、Webアプリケーションの侵害や機密情報の窃取につながる攻撃経路を提供します。 Webサイトは通常、トランスポート層での暗号化を提供するためにSSL/TLS (Secure Sockets Layer / Transport Layer Security) を使用します。 しかし、WebサイトがSSL/TLSを適切に設定・使用していない場合、通信の傍受や改ざんに対して脆弱になる可能性があります。

トランスポート層暗号化の欠如
トランスポート層が暗号化されていない場合、Webサイトとクライアント間のすべての通信が平文で送信されます。
 
トランスポート層暗号化の欠如
トランスポート層が暗号化されていない場合、Webサイトとクライアント間のすべての通信が平文で送信されます。これにより、傍受、注入、リダイレクト (中間者攻撃/MITM攻撃) に対して脆弱になります。   
  受動的攻撃
攻撃者は通信を受動的に傍受し、送信中のユーザー名やパスワードなどの機密データにアクセスする可能性があります。  
  能動的攻撃
攻撃者は通信に対してコンテンツを能動的に注入・削除することで、以下が可能になります: 情報の偽造・省略、悪意あるスクリプトの注入、クライアントを信頼できないリモートコンテンツにアクセスさせる。  
  通信のリダイレクト
攻撃者は通信をリダイレクトし、Webサイトとクライアントが互いに通信していると思わせながら、実際には攻撃者と通信させることが可能です。

弱い暗号のサポート
かつて高度な暗号化技術はアメリカ合衆国外への輸出が制限されていました。 そのため、Webサイトは輸出制限のあるクライアント向けに弱い暗号化オプションをサポートするよう設定されていました。 弱い暗号は比較的容易に破られるため、攻撃に対して脆弱です; 一般的な家庭用コンピューターで2週間未満、専用ハードウェアを使用すれば数秒です。
現在、すべてのモダンブラウザとWebサイトは強力な暗号化を使用していますが、一部のWebサイトは依然として時代遅れの弱い暗号をサポートしています。 このため、攻撃者はWebサイトに接続する際、クライアントを弱い暗号に強制的にダウングレードさせ、その弱い暗号を破ることが可能です。 この理由により、サーバーは強い暗号のみを受け入れ、弱い暗号の使用を要求するクライアントにはサービスを提供しないよう設定されるべきです。 さらに、一部のWebサイトは、クライアントがより強力な暗号をサポートしているにも関わらず、弱い暗号を選択するよう誤設定されています。 OWASPは弱い暗号のサポートや設定ミスを含むSSL/TLS問題のテストガイドを提供しています。 その他のリソースやツールも利用可能です。</desc>
	<solution>フェーズ：要件定義
暗号化による保護が必要な価値の高いデータやリソースを明確に特定してください。
 データ・リソースの送信や保存には、実績のある暗号化アルゴリズムの使用を必須要件としてください。

フェーズ：アーキテクチャと設計
  データ保護戦略の策定
  脅威モデリングやその他の手法を用いて、データが別の脆弱性や弱点を通じて侵害される可能性を想定し、暗号化が最も効果的な場所を特定してください。 プライベートなデータが、不適切なアクセス権限設定 (CWE-732) などの弱点により意図せず露出していないことを確認してください。

  システム全体への暗号化統合
  暗号化をシステム設計に適切に組み込むことを確保してください：
   * ユーザーデータ保護: システムユーザーの個人データの保存・送信に必要な暗号化
   * システム保護: システム自体を不正な開示や改ざんから守るために必要な暗号化
  暗号化のニーズとコンテキストを明確に区別してください：
   * 一方向暗号化: ユーザーまたは受信者のみが鍵を保有 
     これは公開鍵暗号方式、または暗号化側 (つまり、ソフトウェア) が秘密鍵にアクセスする必要がないその他の技術を使用して実現できます。
      * 双方向暗号化: ユーザーに代わって自動暗号化・復号が必要 
     これには、ユーザー (または場合によってはオペレーティングシステム) のみが復元でき、他者が復元できない形式での秘密鍵の保存が必要です。

  独自アルゴリズムの禁止
  独自の暗号化アルゴリズムは開発しないでください。理由：
    * 暗号学者に既知の攻撃手法にさらされるリスク
    * リバースエンジニアリング技術の成熟
    * 動作原理の発覚に特に脆弱

  実績あるアルゴリズムの採用
  専門家によって現在強力と認められた、十分に検証されたアルゴリズムと、テスト済み実装を選択してください：
   * 米国政府システムはFIPS 140-2認証を要求
   * すべての暗号化メカニズムは分析用にソースコード公開が必要
   * 定期的な暗号化技術の見直しを実施
      かつて10億年の計算時間が必要とされた古いアルゴリズムが、現在では数日〜数時間で破られる可能性があります。 これにはMD4、MD5、SHA1、DES、およびかつて強力と見なされていたその他のアルゴリズムが含まれます。

  システム分離設計
  信頼境界を明確に定義できる「セキュア領域」を設けてシステムを分離してください：
    * 機密データの信頼境界外への流出防止
   * セキュア領域外の区画とのインターフェースでは細心の注意

フェーズ：実装; アーキテクチャと設計
  業界標準技術を使用する際は、正しい実装を心がけてください。 リソース集約的なステップを省略することで手を抜かないでください (CWE-325)。 これらのステップは、一般的な攻撃を防ぐために不可欠な場合が多いです。

  セキュアコーディングの実践
  機密データが使用される箇所を特定しやすくするために、命名規則と強い型を使用してください。 構造体、オブジェクト、またはその他の複雑なエンティティを作成する際は、機密データと非機密データを可能な限り分離してください。
これにより、コード内で暗号化されていないデータが使用されている箇所を特定しやすくなります。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/311.html</reference>
</vuln_item_wasc_4>

<vuln_items>wasc_5</vuln_items>
<vuln_item_wasc_5>
	<alert>リモート ファイルインクルード</alert>
	<desc>リモートファイルインクルード (RFI) は、Webアプリケーションの動的ファイル読み込み機能を悪用した攻撃手法です。 Webアプリケーションがユーザー入力（URL、パラメーター値など）を受け取り、それらをファイル読み込み関数に渡す際、攻撃者が悪意のあるコードを含むリモートファイルを読み込ませることが可能になる脆弱性です。

ほぼすべてのWebアプリケーションフレームワークがファイル読み込み機能をサポートしています。 この機能は主に、共通処理を独立したファイルに分離し、メインアプリケーションモジュールから参照するために使用されます。 Webアプリケーションがインクルードファイルを参照する際、そのファイル内のコードは特定の関数呼び出しにより自動的または明示的に実行されます。 読み込むモジュールの選択がHTTPリクエストの要素 (パラメーター等) に基づいて行われる場合、そのWebアプリケーションはRFI攻撃に対して脆弱になる可能性があります。
攻撃者はRFIを以下の目的で使用できます：
    * サーバー上で悪意のあるコードを実行する: インクルードされた悪意のあるファイル内のコードは、サーバーによって実行されます。 ファイルインクルードが何らかのラッパーを使用せずに実行される場合、インクルードファイル内のコードはサーバーユーザーのコンテキストで実行されます。 これは完全なシステム侵害につながる可能性があります。
    * クライアント上で悪意のあるコードを実行する：攻撃者の悪意のあるコードは、クライアントに送信されるレスポンスの内容を操作できます。 攻撃者はクライアントによって実行される悪意のあるコード (例: クライアントのセッションCookieを盗むためのJavaScript) をレスポンスに埋め込むことができます。

PHPはPHPプログラミングにおける「ファイルインクルード」の広範な使用と、RFI攻撃に対する脆弱性を高めるデフォルトのサーバー設定のため、特にRFI攻撃に対して脆弱です。</desc>
	<solution>フェーズ: アーキテクチャおよび設計
ファイル名やURLなど、許容されるオブジェクトのセットが限定されているか既知である場合、固定の入力値 (数値IDなど) から実際のファイル名やURLへのマッピングを作成し、他のすべての入力を拒否してください。
例えば、ID 1は "inbox.txt" に、ID 2は "profile.txt" にマッピングできます。 ESAPI AccessReferenceMap のような機能がこの能力を提供します。

フェーズ: アーキテクチャおよび設計、運用
プロセスとオペレーティングシステムとの間に厳格な境界を強制する "jail" または同様のサンドボックス環境でコードを実行してください。 これにより、特定のディレクトリでアクセスできるファイルや、ソフトウェアが実行できるコマンドを効果的に制限できます。
OSレベルの例には、Unixのchroot jail、AppArmor、SELinuxがあります。 一般的に、マネージドコードはいくらかの保護を提供できます。 例えば、Java SecurityManager の java.io.FilePermission は、ファイル操作に制限を指定できます。
この手法は実装が困難である可能性があり、オペレーティングシステムへの影響は軽減できても、アプリケーション層での脆弱性は残存する可能性があります。
CWE-243 や jail に関連する他の弱点を避けるように注意してください。
PHPの場合、インタプリタは open_basedir や safe_mode などの制限を提供し、攻撃者がアプリケーションから抜け出すのをより困難にすることができます。 また、より危険なPHPの機能を無効にするさまざまなオプションを含む、強化されたPHP拡張機能であるSuhosinを検討してください。

フェーズ: 実装
すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。
入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。
ファイル名については、使用する文字セットを制限する厳格な許可リストを使用してください。 可能であれば、CWE-23などの弱点を避けるためにファイル名に "." 文字を1つだけ許可し、CWE-36を避けるために "/" などのディレクトリ区切り文字を除外してください。 許容されるファイル拡張子の許可リストを使用することで、CWE-434を回避するのに役立ちます。

フェーズ: アーキテクチャおよび設計、運用
可能であれば、ライブラリ、インクルード、およびユーティリティファイルをWebドキュメントルートの外に保存してください。 そうでない場合は、別のディレクトリに保存し、Webサーバーのアクセスコントロール機能を使用して、攻撃者が直接リクエストするのを防いでください。 一般的な方法の1つは、各呼び出し元プログラムで固定の定数を定義し、ライブラリ/インクルードファイルでその定数の存在を確認することです。定数が存在しない場合、ファイルは直接リクエストされたことになり、即座に終了できます。
これにより、基本プログラムにはあるがインクルードファイルにはない保護メカニズムを攻撃者がバイパスできる可能性が大幅に減少します。 また、攻撃対象領域も減少します。

フェーズ：アーキテクチャおよび設計、実装
パラメーターや引数、クッキー、ネットワークから読み取られるもの、環境変数、逆引きDNSルックアップ、クエリ結果、リクエストヘッダ、URLコンポーネント、電子メール、ファイル、データベース、そしてアプリケーションにデータを提供する外部システムなど、信頼できない入力がソフトウェアに入る可能性のあるすべての領域を理解してください。 そのような入力は、API呼び出しを介して間接的に取得される可能性があることを忘れないでください。
多くのファイルインクルードの問題は、プログラマーが特定の入力、特にクッキーやURLコンポーネントが変更されないと仮定したために発生します。</solution>
	<reference>https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.2-Testing_for_Remote_File_Inclusion</reference>
	<reference>https://cwe.mitre.org/data/definitions/98.html</reference>
</vuln_item_wasc_5>

<vuln_items>wasc_6</vuln_items>
<vuln_item_wasc_6>
	<alert>書式文字列攻撃</alert>
	<desc>書式文字列攻撃は文字列フォーマットライブラリの機能を使用して他のメモリー空間にアクセスし、アプリケーションのフローを変更する攻撃です。 この脆弱性はユーザーが提供したデータが特定のC/C++関数 (例: fprintf, printf, sprintf, setproctitle, syslog, ...) の書式文字列入力として直接使用される場合に発生します。

攻撃者がprintf変換文字 (例: "%f", "%p", "%n" など) で構成されるフォーマット文字列をパラメーター値としてWebアプリケーションに渡すと、以下のことが可能になります：
    * サーバー上で任意のコードを実行する
    * スタックから値を読み取る
    * セグメンテーション違反 / ソフトウェアのクラッシュを引き起こす

フォーマット文字列攻撃は脅威分類における他の攻撃、すなわちバッファオーバーフローや整数オーバーフローと関連しています。 これら3つはすべて、攻撃者の目標達成に貢献する方法でメモリやその解釈を操作する能力に基づいています。</desc>
	<solution>フェーズ: 要件
この欠陥が発生しない言語を選択してください。

フェーズ: 実装
すべての書式文字列関数に、ユーザーが制御できないパッシブな文字列が渡され、その関数に適切な数の引数が常に送信されることを確認してください。 可能であれば、フォーマット文字列で %n 演算子をサポートしない関数を使用してください。
ビルド: コンパイラやリンカの警告に注意してください。不適切な使用法を警告してくれる可能性があります。
</solution>
	<reference>https://owasp.org/www-community/attacks/Format_string_attack</reference>
	<reference>https://cwe.mitre.org/data/definitions/134.html</reference>
</vuln_item_wasc_6>

<vuln_items>wasc_7</vuln_items>
<vuln_item_wasc_7>
	<alert>バッファオーバーフロー</alert>
	<desc>バッファオーバーフローはメモリのブロック (バッファ) に割り当てられた容量よりも多くのデータが書き込まれるときに発生する欠陥です。 バッファオーバーフローを悪用すると、攻撃者はターゲットプロセスのメモリアドレス空間の一部を変更できます。 この能力は、以下のような多くの目的で使用できます：
    * プロセスの実行を制御する
    * プロセスをクラッシュさせる
    * 内部変数を変更する

攻撃者の目標は、ほとんどの場合、ターゲットプロセスの実行を制御することです。 これは、オーバーフローを使用して直接的または間接的に変更できるメモリ内の関数ポインタを特定することによって達成されます。 プログラムがそのようなポインタを使用してジャンプまたはコール命令によってプログラムの実行を指示するとき、攻撃者が指定した命令の場所が使用され、それによって攻撃者はプロセスを制御できます。

多くの場合、関数ポインタは、攻撃者がアセンブルされたマシン固有の命令を配置した場所を参照するように変更されます。 これらの命令は、攻撃者が実行中のプロセスのコンテキストでコマンドライン環境 (シェル) を起動したいという事実から、一般的にシェルコードと呼ばれます。

バッファオーバーフローはCおよびC++プログラミング言語で書かれたソフトウェアに最もよく関連付けられています。これは、これらの言語が広く使用されており、一般的なプログラミング構造で直接的なメモリ操作が可能であるためです。 しかし、バッファオーバーフローはコンパイラ、ランタイムライブラリの欠陥、または言語自体の機能を通じて直接的なメモリ操作が許可されているあらゆるプログラミング環境に存在する可能性があることを強調しておくべきです。
</desc>
	<solution>フェーズ：要件
この脆弱性が発生しない言語を使用するか、この脆弱性を回避しやすくする構造を提供する言語を使用してください。
例えば、JavaやPerlのように独自のメモリ管理を行う多くの言語はバッファオーバーフローの影響を受けません。 AdaやC#のような他の言語は通常オーバーフロー保護を提供しますが、プログラマーによって無効にすることができます。
言語自体が理論的に安全であっても、言語のネイティブコードへのインターフェースは依然としてオーバーフローの影響を受ける可能性があることに注意してください。

フェーズ: アーキテクチャおよび設計
この脆弱性が発生しない、またはこの脆弱性を回避しやすくする構造を提供する、実績のあるライブラリやフレームワークを使用してください。
例としては、MessierとViegaによるSafe C String Library (SafeStr)や、MicrosoftのStrsafe.hライブラリがあります。 これらのライブラリはオーバーフローしやすい文字列処理関数のより安全なバージョンを提供します。 これは完全な解決策ではありません。なぜなら、多くのバッファオーバーフローは文字列に関連していないからです。

フェーズ: ビルドおよびコンパイル
バッファオーバーフローを軽減または排除する保護メカニズムを自動的に提供する機能や拡張機能を使用して、ソフトウェアを実行またはコンパイルしてください。
例えば、特定のコンパイラや拡張機能はコンパイルされたコードに組み込まれた自動的なバッファオーバーフロー検出メカニズムを提供します。 例としては、Microsoft Visual Studioの /GS フラグ、Fedora/Red Hatの FORTIFY_SOURCE GCC フラグ、StackGuard、ProPolice があります。

フェーズ: 実装
アプリケーションのメモリを割り当て、管理する際には、以下のルールに従うことを検討してください：
      バッファが指定したサイズであることを再確認してください。
      strncpy() のようにコピーするバイト数を受け入れる関数を使用する場合、宛先バッファサイズがソースバッファサイズと等しい場合、文字列がNULLで終端されない可能性があることに注意してください。
      この関数をループ内で呼び出す場合はバッファの境界を確認し、割り当てられたスペースを超えて書き込む危険がないことを確認してください。
      必要に応じて、すべての入力文字列を適切な長さに切り捨ててから、コピーおよび連結関数に渡してください。

フェーズ：運用
アドレス空間配置のランダム化 (ASLR) のような機能を使用してください。

フェーズ：運用

データ実行防止 (NX) またはそれに相当する機能を提供するCPUとオペレーティングシステムを使用してください。

フェーズ: 実装

制限のないコピー関数を長さ引数をサポートする類似の関数に置き換えてください、strcpy を strncpy で置き換えるなど。 利用できない場合は作成してください。
</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/Buffer_Overflow</reference>
	<reference>https://cwe.mitre.org/data/definitions/119.html</reference>
</vuln_item_wasc_7>

<vuln_items>wasc_8</vuln_items>
<vuln_item_wasc_8>
	<alert>クロスサイト スクリプティング(XSS)</alert>
	<desc>クロスサイトスクリプティング (XSS) は、攻撃者が提供したコードをユーザーのブラウザインスタンスに反映 (echo) させる攻撃手法です。 ブラウザインスタンスには、標準的なWebブラウザクライアントのほか、WinAmp内のブラウザ、RSSリーダー、メールクライアントなどのソフトウェア製品に埋め込まれたブラウザオブジェクトも含まれます。 コード自体は通常HTML/JavaScriptで記述されますが、VBScript、ActiveX、Java、Flash、その他ブラウザがサポートするあらゆる技術に及ぶ可能性があります。
攻撃者がユーザーのブラウザに自身のコードを実行させると、そのコードはホスティングしているWebサイトのセキュリティコンテキスト (またはゾーン) 内で実行されます。 この権限レベルでは、コードはブラウザがアクセス可能なあらゆる機密データの読み取り、変更、送信する能力を持ちます。 クロスサイトスクリプティングの被害を受けたユーザーは、アカウントを乗っ取られたり (Cookie窃取)、ブラウザを別の場所にリダイレクトされたり、訪問しているWebサイトから配信される詐欺的なコンテンツを表示させられたりする可能性があります。 クロスサイトスクリプティング攻撃は本質的にユーザーとWebサイトとの間の信頼関係を侵害します。 ファイルシステムからコンテンツを読み込むブラウザオブジェクトインスタンスを利用するアプリケーションはローカルマシンゾーン下でコードを実行する可能性があり、システムの侵害につながる可能性があります。

クロスサイトスクリプティング攻撃には、非永続的 (non-persistent)、永続的 (persistent)、DOMベースの3つのタイプがあります。
非永続的攻撃とDOMベース攻撃では、ユーザーは悪意のあるコードが仕込まれた特別に細工されたリンクを訪問するか、脆弱なサイトにPOSTすると攻撃を開始する悪意のあるWebフォームを含むWebページを訪問する必要があります。 悪意のあるフォームの使用は、脆弱なリソースがHTTP POSTリクエストのみを受け付ける場合によく行われます。 そのような場合、フォームは (例えばJavaScriptを使用して) 被害者の知らないうちに自動的に送信されることがあります。 悪意のあるリンクをクリックするか悪意のあるフォームを送信すると、XSSペイロードが反映されてユーザーのブラウザによって解釈され、実行されます。 Adobe Flashのような埋め込みクライアントを使用することで、ほぼ任意のリクエスト (GETおよびPOST) を送信する手法もあります。
永続的攻撃は、悪意のあるコードがWebサイトに送信され、一定期間保存される場合に発生します。 攻撃者のお気に入りのターゲットの例には、メッセージボードの投稿、Webメールのメッセージ、Webチャットソフトウェアなどがよく含まれます。 疑いを持たないユーザーは、追加のサイト/リンク (例: 攻撃者のサイトやメールで送信された悪意のあるリンク) と対話する必要はなく、単にコードを含むWebページを表示するだけで被害に遭います。</desc>
	<solution>フェーズ: アーキテクチャおよび設計
この脆弱性が発生しない、またはこの脆弱性を回避しやすくする構造を提供する、実績のあるライブラリやフレームワークを使用してください。
適切にエンコードされた出力を生成しやすくするライブラリやフレームワークの例には、MicrosoftのAnti-XSSライブラリ、OWASP ESAPIのEncodingモジュール、Apache Wicketなどがあります。

フェーズ: 実装、アーキテクチャおよび設計
データが使用されるコンテキストと期待されるエンコーディングを理解してください。 これは、異なるコンポーネント間でデータを転送する場合や、Webページやマルチパートメールメッセージのように複数のエンコーディングを同時に含む可能性のある出力を生成する場合に特に重要です。 期待されるすべての通信プロトコルとデータ表現を調査し、必要なエンコーディング戦略を決定してください。
別のWebページに出力されるデータ、特に外部入力から受け取ったデータについては、すべての非英数字に対して適切なエンコーディングを使用してください。
必要なエンコーディングとエスケープの種類の詳細については、XSS対策チートシートを参照してください。

フェーズ: アーキテクチャおよび設計
クライアント側で実行されるセキュリティチェックについては、CWE-602を回避するために、これらのチェックがサーバー側で複製されていることを確認してください。 攻撃者は、チェックが実行された後に値を変更したり、クライアントを変更してクライアント側のチェックを完全に削除したりすることで、クライアント側のチェックをバイパスできます。 その後、これらの変更された値がサーバーに送信されます。

利用可能であれば、データとコードの分離を自動的に強制する構造化されたメカニズムを使用してください。 これらのメカニズムは、開発者が出力を生成するすべての箇所でこの機能を提供することに頼るのではなく、関連するクォーティング、エンコーディング、および検証を自動的に提供できる場合があります。

フェーズ: 実装
生成されるすべてのWebページについて、ISO-8859-1やUTF-8などの文字エンコーディングを使用し、指定してください。 エンコーディングが指定されていない場合、WebブラウザはWebページで実際に使用されているエンコーディングを推測して、異なるエンコーディングを選択する可能性があります。 これにより、Webブラウザが特定のシーケンスを特殊なものとして扱い、クライアントが巧妙なXSS攻撃にさらされる可能性があります。 エンコーディング/エスケープに関連するその他の緩和策については、CWE-116を参照してください。

ユーザーのセッションクッキーに対するXSS攻撃を緩和するために、セッションCookieを HttpOnly に設定してください。 HttpOnly 機能をサポートするブラウザ (最近のバージョンのFirefoxなど) では、この属性により document.cookie を使用する悪意のあるクライアントサイドスクリプトがユーザーのセッションCookieにアクセスするのを防ぐことができます。 これは完全な解決策ではありません。なぜなら、HttpOnly はすべてのブラウザでサポートされているわけではないからです。 さらに重要なことに、XMLHTTPRequest やその他の強力なブラウザ技術は、HttpOnlyフラグが設定されている Set-Cookie ヘッダーを含むHTTPヘッダーへの読み取りアクセスを提供します。

すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

アプリケーション内の明確に定義されたインターフェースで入力検証を実行することを確認してください。 これにより、コンポーネントが再利用されたり、他の場所に移動されたりしても、アプリケーションを保護するのに役立ちます。
	</solution>
	<reference>https://owasp.org/www-community/attacks/xss/</reference>
	<reference>https://cwe.mitre.org/data/definitions/79.html</reference>
</vuln_item_wasc_8>

<vuln_items>wasc_9</vuln_items>
<vuln_item_wasc_9>
	<alert>クロスサイト リクエスト フォージェリー(CSRF)</alert>
	<desc>CSRF攻撃は被害者の知識や同意なしに標的Webサイトに対してHTTPリクエストを送信させ、被害者の権限で不正な操作を実行させる攻撃手法です。 根本原因は、アプリケーションが予測可能なURL/フォームアクションを使用していることにあります。 この攻撃の性質は、CSRFがWebサイトがユーザーに対して持つ信頼を悪用することです。 対照的に、クロスサイトスクリプティング (XSS) は、ユーザーがWebサイトに対して持つ信頼を悪用します。 XSSと同様に、CSRF攻撃は必ずしもクロスサイトである必要はありませんが、クロスサイトになることもあります。 クロスサイトリクエストフォージェリはCSRF、XSRF、ワンクリック攻撃、セッションライディング、混乱した代理人 (confused deputy)、シーサーフ (sea surf) としても知られています。

CSRF攻撃は以下のような状況で効果的です：
    * 被害者が標的サイトでアクティブなセッションを持っている場合
    * 被害者が標的サイトでHTTP認証により認証されている場合
    * 被害者が標的サイトと同じローカルネットワーク上にいる場合

CSRFは主に被害者の権限を使用して標的サイトに対してアクションを実行するために使用されてきましたが、レスポンスへのアクセスを獲得することで情報を開示する最近の技術が発見されています。 標的サイトがXSSに脆弱である場合、情報開示のリスクは劇的に増加します。なぜなら、XSSはCSRFのプラットフォームとして使用でき、同一オリジンポリシーの範囲内で攻撃を動作させることができるからです。</desc>
	<solution>フェーズ: アーキテクチャおよび設計
この脆弱性が発生しない、またはこの脆弱性を回避しやすくする構造を提供する、実績のあるライブラリやフレームワークを使用してください。
たとえば、OWASP CSRFGuard などのAnti-CSRFパッケージを使用します。

フェーズ：実装
XSSの脆弱性が存在する場合、多くのCSRF防御策が無効化される可能性があるため、アプリケーションにクロスサイトスクリプティングの脆弱性がないことを確認してください。

フェーズ: アーキテクチャと設計
各フォームに対して一意のNonceを生成し、Nonceをフォームに配置し、フォームを受け取った際にNonceを検証する。 Nonceは予測不可能なものにする (CWE-330)
これはXSSを利用してバイパスされる可能性があることに注意してください。

特に危険な操作を特定してください。 ユーザーが危険な操作を実行する際には別の確認リクエストを送信し、ユーザーがその操作を意図したことを確認してください。
これはXSSを利用してバイパスされる可能性があることに注意してください。

ESAPIのセッション管理コントロールを使用してください。
このコントロールにはCSRF対策コンポーネントが含まれています。

状態を変更するリクエストにはGETメソッドを使用しないでください。

フェーズ: 実装
HTTPの Referer ヘッダーをチェックし、リクエストが予期されたページから送信されたものであるかを確認してください。 ただし、この方法はユーザーやプロキシがプライバシー上の理由でRefererの送信を無効にしている場合に、正当な機能を妨げる可能性があります。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/352.html</reference>
</vuln_item_wasc_9>

<vuln_items>wasc_10</vuln_items>
<vuln_item_wasc_10>
	<alert>DoS(サービス運用妨害)</alert>
	<desc>サービス拒否 (DoS) はWebサイトが通常のユーザーアクティビティを提供できなくすることを意図した攻撃手法です。 通常はネットワーク層に対して行われるDoS攻撃ですが、アプリケーション層でも可能です。 これらの悪意ある攻撃は、システムの重要なリソースを枯渇させたり、脆弱性を悪用したり、機能を乱用したりすることによって成功します。

多くの場合、DoS攻撃はWebサイトが利用可能なすべてのシステムリソース (CPU、メモリ、ディスクスペースなど) を消費しようと試みます。 これらの重要なリソースのいずれかが最大使用率に達すると、Webサイトは通常アクセス不能になります。

今日のWebアプリケーション環境にはWebサーバー、データベースサーバー、認証サーバーが含まれているため、アプリケーション層でのDoSはこれらの各コンポーネントを標的にする可能性があります。 多数の接続試行が必要なネットワーク層のDoSとは異なり、アプリケーション層でのDoSは実行がはるかに簡単なタスクです。</desc>
	<solution>フェーズ: アーキテクチャおよび設計

システムアーキテクチャにスロットリング (流量制限) メカニズムを設計してください。 最善の保護策は、認証されていないユーザーが消費させることができるリソースの量を制限することです。 強力な認証およびアクセスコントロールモデルは、そもそもそのような攻撃が発生するのを防ぐのに役立ちます。 ログインアプリケーションは可能な限りDoS攻撃から保護する必要があります。 おそらく結果セットをキャッシュすることによりデータベースアクセスを制限することが、消費されるリソースを最小限に抑えるのに役立ちます。 DoS攻撃の可能性をさらに制限するために、ユーザーから受信したリクエストのレートを追跡し、定義されたレートしきい値を超えるリクエストをブロックすることを検討してください。

リソース枯渇攻撃の緩和には、標的システムが以下のいずれかを行う必要があります：
      * 攻撃を認識し、そのユーザーからのさらなるアクセスを一定時間拒否する。
      * 全リクエストに対する一律制限 (レート制限) により、攻撃者がリソース解放速度を上回る消費を行うことを困難にする。 

最初の解決策は正規ユーザーに対するサービス拒否攻撃を招く可能性があるため、それ自体が問題です。 攻撃者が正規のユーザーIDを使用して意図的に認証を失敗させることで、そのユーザーのアクセスを阻止できるためです。

2番目の解決策は、効果的に実装することが単純に困難であり、適切に実行された場合でも完全な解決策を提供しません。 これは単に、攻撃者がより多くのリソースを必要とするだけです。

各プロトコルレイヤーでスケーラビリティ制限が設けられていることを確認してください。

フェーズ: 実装
リソース割り当て失敗時は、システムを安全な状態に移行することを確保してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_10>

<vuln_items>wasc_11a</vuln_items>
<vuln_item_wasc_11a>
	<alert>総当たり (ログイン認証情報)</alert>
	<desc>総当たり攻撃 (ブルートフォースアタック) は自動化されたプロセスを用いて多数の可能な値を試すことで、未知の値を特定する手法です。 この攻撃は、値のエントロピーが認識されているよりも小さいという事実を利用します。 例えば、8文字の英数字パスワードには2.8兆通りの可能な値がありますが、多くの人々は一般的な単語や用語からなるはるかに小さなサブセットからパスワードを選びます。

Webアプリケーションにおける最も一般的な総当たり攻撃はログイン認証情報に対する攻撃です。 ユーザーはパスワードを覚える必要があるため、覚えやすい単語やフレーズをパスワードとして選ぶことが多く、辞書を使用した総当たり攻撃が有効になります。 このような、多数の単語やフレーズのリストをパスワード候補としてシステムにログインを試みる攻撃は、しばしば「ワードリスト攻撃」または「辞書攻撃」と呼ばれます。 試されるパスワードには、「o」を「0」に、「i」を「1」に置き換えるといったパスワードによくある単語のバリエーションや、家族の名前、誕生日、電話番号などの個人情報も含まれることがあります。
	</desc>
	<solution>総当たり攻撃は防ぐのが最も困難な攻撃の一つですが、徹底的な分析、設計、そして複数の対策を講じることで、システムが攻撃にさらされる危険性を制限できます。 一般的な戦略は自動化の可能性と認証情報の発見しやすさを低減させることです。 検討すべき技術には以下が含まれます：
    * パスワードポリシー: 十分な長さで、一般的でない単語、数字、特殊文字を含む複雑なパスワードの要件を実装する。
    * 多要素認証 (MFA): MFAはユーザーが認証メカニズムに複数の種類の証拠を提供することを要求し、それによって自動化の可能性を制限する。
    * CAPTCHA: CAPTCHAは自動化の可能性を低減させることを目的とする。
    * Webアプリケーションファイアウォール (WAF): WAFは悪意のあるトラフィックのパターンを検出し、ブルートフォース攻撃を認識してブロックするのに役立つ。
    * レート制限: 一定期間内に単一のIPアドレスからの失敗したログイン試行回数を制限することで、自動化の可能性を制限する。
    * アカウントロックアウト: 定義された回数のログイン失敗後、アカウントを一定期間ロックする。
サービス拒否のような乱用や負の副作用を防ぐためには、ユーザーのシステムへのアクセスを制限するために使用される技術が適切に実装されることが重要です。

さらに、パスキーのようなパスワードレス認証メカニズムへの移行も検討してください。</solution>
	<reference>https://owasp.org/www-community/attacks/Brute_force_attack</reference>
</vuln_item_wasc_11a>

<vuln_items>wasc_11b</vuln_items>
<vuln_item_wasc_11b>
	<alert>総当たり (セッション識別子)</alert>
	<desc>総当たり攻撃 (ブルートフォースアタック) は自動化されたプロセスを用いて多数の可能な値を試すことで、未知の値を特定する手法です。 この攻撃は、値のエントロピーが認識されているよりも小さいという事実を利用します。 例えば、8文字の英数字パスワードには2.8兆通りの可能な値がありますが、多くの人々は一般的な単語や用語からなるはるかに小さなサブセットからパスワードを選びます。

HTTPはステートレスなプロトコルであるため、状態を維持するためにWebアプリケーションは各リクエストと共にブラウザからセッションIDが送信されることを保証する必要があります。 セッションIDは最も一般的にはHTTPクッキーやURLに保存されます。 ブルートフォース攻撃を用いることで、攻撃者は他のユーザーのセッションIDを推測することができます。 これにより、攻撃者はユーザーになりすまし、個人情報を取得し、ユーザーに代わってアクションを実行することが可能になります。
	</desc>
	<solution>ランダムで、一時的で、予測不可能なセッションIDを生成するメカニズムを使用してください。</solution>
	<reference>https://owasp.org/www-community/attacks/Brute_force_attack</reference>
</vuln_item_wasc_11b>

<vuln_items>wasc_11c</vuln_items>
<vuln_item_wasc_11c>
	<alert>総当たり (ディレクトリとファイル)</alert>
	<desc>総当たり攻撃 (ブルートフォースアタック) は自動化されたプロセスを用いて多数の可能な値を試すことで、未知の値を特定する手法です。 この攻撃は、値のエントロピーが認識されているよりも小さいという事実を利用します。 例えば、8文字の英数字パスワードには2.8兆通りの可能な値がありますが、多くの人々は一般的な単語や用語からなるはるかに小さなサブセットからパスワードを選びます。

ファイルがWebサーバーによって提供されるディレクトリ内に存在するものの、どこからもリンクされていない場合、それらのファイルにアクセスするにはファイル名を知る必要があります。 場合によっては、これらのファイルは誤って残されたものです。例えば、ファイルを編集する際に自動的に作成されたバックアップファイルや、Webアプリケーションの古いバージョンからの残骸などです。 また、意図的にリンクされずに「不明瞭さによるセキュリティ (security by obscurity)」メカニズムとして残されている場合もあり、ファイル名を知っている人だけがアクセスできるようになっています。

総当たり攻撃は多数のファイルにアクセスを試みることで、リンクされていないファイルを見つけ出そうとします。 試行されるファイル名のリストは、既知の潜在的なファイルのリストから取られるか、Webサイト上で見えるファイルのバリエーションに基づいています。 ディレクトリとファイルのブルートフォースに関する詳細は、関連する脆弱性である「予測可能なリソース配置」で詳しく説明されています。
	</desc>
	<solution>Webサーバー上の機密ファイルやディレクトリへのアクセスを制限するために、「不明瞭さによるセキュリティ」メカニズムに決して依存しないでください。 機密情報をホストする必要がある場合、適切なアクセスコントロール手段を実装してください。</solution>
	<reference>https://owasp.org/www-community/attacks/Forced_browsing</reference>
</vuln_item_wasc_11c>

<vuln_items>wasc_11d</vuln_items>
<vuln_item_wasc_11d>
	<alert>総当たり (クレジットカード情報)</alert>
	<desc>総当たり攻撃 (ブルートフォースアタック) は自動化されたプロセスを用いて多数の可能な値を試すことで、未知の値を特定する手法です。 この攻撃は、値のエントロピーが認識されているよりも小さいという事実を利用します。 例えば、8文字の英数字パスワードには2.8兆通りの可能な値がありますが、多くの人々は一般的な単語や用語からなるはるかに小さなサブセットからパスワードを選びます。

盗まれたクレジットカードでオンラインショッピングを行うには、通常、クレジットカード番号に加えて、CVV/CSCや有効期限などの追加情報が必要です。 詐欺師は追加情報なしに盗まれたクレジットカード番号を持っている場合があります。 例えば、CVV/CSCはカードに刻印されておらず、磁気ストライプにも保存されていないため、機械的または磁気的なクレジットカード読み取り装置では収集できません。

不足している情報を補うために、ハッカーはブルートフォース技術を用いて不足情報を推測し、すべての可能な値を試すことができます。
    * CVV/CSCの推測は、番号がカードの種類に応じて3桁または4桁であるため、わずか1000回または10000回の試行で済みます。
    * 有効期限の推測は数十回の試行で済みます。
	</desc>
		<solution>フェーズ: アーキテクチャおよび設計
クレジットカード情報に対する総当たり攻撃のリスクを軽減するために、以下のベストプラクティスに従ってください：

* CAPTCHA保護: 支払いプロセス中にCAPTCHAチャレンジを導入し、人間と自動化された試行を区別します。 CAPTCHAは自動化されたブルートフォース攻撃を防ぐのに役立ちます。
* レート制限: 支払い試行にレート制限を実装します。 特定の時間枠内に単一のIPアドレスまたはユーザーアカウントからのリクエスト数を制限します。
* 多要素認証 (MFA): オンライン支払いを含む機密性の高い取引には多要素認証を要求します。 MFAは複数の要素を通じてユーザーの身元を確認することで、セキュリティの層を追加し、総当たり攻撃をより困難にします。
* 安全なデータストレージ: クレジットカード情報が安全に保存され、暗号化されていることを確認します。 機密データへのアクセスを許可された担当者のみに制限します。
* 継続的な監視: 複数回の失敗した支払い試行を含む疑わしい活動を検出し、対応するために継続的な監視を実装します。
* PCI DSSへの準拠: アプリケーションがクレジットカード情報を処理する場合、クレジットカードデータの取り扱いに関するセキュリティガイドラインを提供するペイメントカード業界データセキュリティ基準 (PCI DSS) の要件に準拠していることを確認してください。

フェーズ: 実装
上記のセキュリティ対策をアプリケーションコード、支払い処理、およびユーザーアカウント管理機能に実装してください。

フェーズ: 運用
セキュリティ対策を定期的に監視・レビューし、進化する脅威や攻撃パターンに適応させてください。

</solution>
	<reference>https://owasp.org/www-community/attacks/Brute_force_attack</reference>
</vuln_item_wasc_11d>

<vuln_items>wasc_12</vuln_items>
<vuln_item_wasc_12>
	<alert>コンテンツスプーフィング</alert>
	<desc>コンテンツスプーフィングは、攻撃者が悪意のあるペイロードを注入し、それが後にWebアプリケーションの正当なコンテンツとして偽って表示されることを可能にする攻撃手法です。
 
テキストのみのコンテンツスプーフィング
ページを動的に構築する一般的なアプローチには、クエリストリング値を介して本文全体またはその一部をページに渡す方法があります。 このアプローチはエラーページや、記事やニュースエントリを提供するサイトで一般的です。 このパラメーターで指定されたコンテンツは後にページに反映され、そのページのコンテンツを提供します。
 
マークアップが反映されるコンテンツスプーフィング
一部のWebページは動的に構築されたHTMLコンテンツソースを使用して提供されます。 例えば、フレームのソース場所 ( <frame src="https://foo.example/file.html"/>) が、URLパラメーター値 (https://foo.example/page?frame_src=https://foo.example/file.html) によって指定されることがあります。 攻撃者は "frame_src" パラメーターの値を "frame_src=https://attacker.example/spoof.html" に置き換えることができるかもしれません。 リダイレクタとは異なり結果として表示されるWebページでは、ブラウザのロケーションバーはユーザーが期待するドメイン (foo.example) のままですが、外部のデータ (attacker.example) は正当なコンテンツによって覆い隠されます。

特別に細工されたリンクは電子メールやインスタントメッセージを介してユーザーに送信されたり、掲示板の投稿に残されたり、クロスサイトスクリプティング攻撃によってユーザーに強制的に表示されたりすることがあります。 攻撃者がユーザーに悪意のあるURLで指定されたWebページを訪問させることができれば、ユーザーは実際にはそうでないにもかかわらず、ある場所からの本物のコンテンツを見ていると信じてしまいます。 ブラウザのロケーションバーには https://foo.example が表示されるため、ユーザーは偽装されたコンテンツを暗黙的に信頼しますが、実際には基盤となるHTMLフレームは https://attacker.example を参照しています。

この攻撃はユーザーとWebサイトとの間に確立された信頼関係を悪用します。 この技術は、偽のログインフォーム、ウェブサイトの改ざん、偽のプレスリリースなどを作成するために使用されてきました。
	</desc>
	<solution>適切なコンテンツセキュリティポリシー (CSP) を実装し、ユーザー入力を決して信頼しないでください。</solution>
	<reference>https://owasp.org/www-community/attacks/Content_Spoofing</reference>
</vuln_item_wasc_12>

<vuln_items>wasc_13</vuln_items>
<vuln_item_wasc_13>
	<alert>情報漏洩</alert>
	<desc>情報漏洩は、アプリケーションがWebアプリケーションの技術的な詳細、環境、またはユーザー固有のデータなどの機密データを公開してしまうアプリケーションの弱点です。 機密データは、攻撃者が標的のWebアプリケーション、そのホスティングネットワーク、またはそのユーザーを悪用するために使用される可能性があります。 したがって、機密データの漏洩は可能な限り制限または防止する必要があります。 情報漏洩の最も一般的な形は、以下の1つ以上の条件の結果として発生します: 機密情報を含むHTML/スクリプトコメントの除去の失敗、不適切なアプリケーションまたはサーバーの構成、または有効なデータと無効なデータに対するページの応答の違い。

本番環境へのプッシュ前にHTML/スクリプトコメントを消去しなかった場合、サーバーのディレクトリ構造、SQLクエリの構造、内部ネットワーク情報などの機密性の高い文脈情報が漏洩する可能性があります。 開発者は開発前段階でのデバッグや統合プロセスを容易にするために、開発するコンテンツ内にインラインコメントを残すことがよくあります。 開発者がコンテンツ内にインラインコメントを含めること自体に害はありませんが、これらのコメントはコンテンツが公開される前にすべて削除されるべきです。

ソフトウェアのバージョン番号や詳細なエラーメッセージ (ASP.NETのバージョン番号など) は不適切なサーバー構成の例です。 この情報は、Webアプリケーションで利用されているフレームワーク、言語、または組み込み関数に関する詳細な洞察を攻撃者に提供するため、攻撃者にとって有用です。 ほとんどのデフォルトのサーバー構成では、デバッグやトラブルシューティング目的でソフトウェアのバージョン番号や詳細なエラーメッセージが提供されます。 構成を変更してこれらの機能を無効にし、この情報の表示を防ぐことができます。

データの有効性に基づいて異なる応答を提供するページも、情報漏洩につながる可能性があります。特に、Webアプリケーションの設計の結果として機密と見なされるデータが明らかにされている場合に当てはまります。 機密データの例には、アカウント番号、ユーザー識別子 (運転免許証番号、パスポート番号、社会保障番号など)、およびユーザー固有の情報 (パスワード、セッション、住所) が含まれます (ただし、これらに限定されません)。 この文脈での情報漏洩は、たとえユーザー自身に対しても平文で公開されるべきではない、機密または秘密と見なされる主要なユーザーデータの公開を扱います。 クレジットカード番号やその他の厳しく規制された情報は、適切な暗号化やアクセスコントロールが既に行われている場合でも、さらなる公開や漏洩から保護する必要があるユーザーデータの典型的な例です。</desc>
	<solution>
    * どの情報が機密と見なされ、どれがそうでないかを明確に定義してください。 プライバシー法、規制要件、およびビジネスニーズを考慮に入れてください。
    * 機密データは、必要な場合にのみ保存してください。
    * DevOpsパイプラインに機密情報のチェックを実装してください。 開発者コメントの削除、デバッグ情報や機密ログの削除、エラーメッセージをあまり詳細にしないようにするなどの措置が考えられます。
    * 機密情報を使用する必要がある状況、例えばバックエンドのマイクロサービスなどでは、信頼境界が適切に描かれていることを確認してください。 例: 適切に構成されたアクセスコントロールを持つ、隔離された、十分に保護されたKubernetesクラスタを設定し、許可されたクライアントにのみアクセスを許可します。
    * ユーザーにエラーメッセージを返す必要がある場合は、「無効なユーザー名」や「無効なパスワード」ではなく、「無効な認証情報」のように、できるだけ一般的なメッセージを使用してください。
    * サードパーティの技術を使用する場合は、そのソフトウェアがどのように機能するか、その構成、およびそれを使用する際のセキュリティリスクを理解してください。 技術を理解した後、必要な機能のみを使用し、それ以外はすべて無効にしてください。
    * 詳細なデバッグメッセージが必要な場合、例えばアプリケーションに新機能を追加する場合などがあります。 この場合、開発環境を本番環境から分離してください。 開発環境には適切なアクセスコントロールが実装されていることを確認してください。
    * すべての機密データは保存する前に暗号化する必要があります。 最新で強力な標準アルゴリズム、プロトコル、およびキーが導入されていることを確認し、適切なキー管理を使用してください。
</solution>
<reference>https://portswigger.net/web-security/information-disclosure</reference>
<reference>https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure</reference>
<reference>https://cwe.mitre.org/data/definitions/200.html</reference>
</vuln_item_wasc_13>

<vuln_items>wasc_14</vuln_items>
<vuln_item_wasc_14>
	<alert>サーバーの設定ミス</alert>
	<desc>サーバー設定不備攻撃はWebサーバーやアプリケーションサーバーに見られる設定上の弱点を悪用します。 多くのサーバーには、アプリケーション、設定ファイル、スクリプト、Webページなど、不要なデフォルトファイルやサンプルファイルが付属しています。 また、コンテンツ管理やリモート管理機能など、不要なサービスが有効になっている場合もあります。 デバッグ機能が有効になっていたり、管理者機能が匿名ユーザーにアクセス可能であったりすることもあります。 これらの機能は、ハッカーが認証方法をバイパスし、場合によっては昇格された権限で機密情報にアクセスする手段を提供する可能性があります。

サーバーにはよく知られたデフォルトのアカウントやパスワードが含まれていることがあります。 サーバーを完全にロックダウンまたは堅牢化 (ハーデニング) しなかった場合、ファイルやディレクトリの権限が不適切に設定されたままになる可能性があります。 SSL証明書や暗号化設定の誤構成、デフォルト証明書の使用、外部システムとの不適切な認証実装は、情報の機密性を損なう可能性があります。

詳細で情報豊富なエラーメッセージは、データ漏洩につながる可能性があり、明らかにされた情報が次のレベルの攻撃を計画するために使用される可能性があります。 サーバーソフトウェアの不正確な構成は、ディレクトリインデックス作成やパストラバーサル攻撃を許す可能性があります。</desc>
	<solution>
    * デフォルトの認証情報を使用しないでください。 すべてのデフォルトのユーザー名とパスワードを強力でユニークな認証情報に置き換えてください。 定期的に更新してください。
    * 機密情報やデバッグ情報を漏洩させない、適切なエラーメッセージ処理戦略を実装してください。
    * 管理者機能が不正なユーザーにアクセスできないようにしてください。 強力な認証および認可メカニズムを実装してください。
    * 使用している特定のサーバーのベストプラクティスとセキュリティガイドラインに従ってください。
   </solution>
	<reference>https://owasp.org/www-project-mobile-top-10/2023-risks/m8-security-misconfiguration</reference>
</vuln_item_wasc_14>

<vuln_items>wasc_15</vuln_items>
<vuln_item_wasc_15>
	<alert>アプリケーションの設定ミス</alert>
	<desc>アプリケーション設定不備攻撃はWebアプリケーションに見られる設定上の弱点を悪用します。 多くのアプリケーションには、デバッグ機能やQA機能など、不要で安全でない機能がデフォルトで有効になっています。 これらの機能は、ハッカーが認証方法をバイパスし、場合によっては昇格された権限で機密情報にアクセスする手段を提供する可能性があります。

同様に、デフォルトのインストールには、よく知られたユーザー名やパスワード、ハードコードされたバックドアアカウント、特別なアクセスメカニズム、Webサーバーを介してアクセス可能なファイルの不適切な権限設定が含まれていることがあります。 デフォルトのサンプルが本番環境でアクセス可能になっている場合もあります。 適切にロックダウンされていないアプリケーションベースの設定ファイルは、データベースへの接続文字列を平文で明らかにする可能性があり、設定ファイルのデフォルト設定はセキュリティを念頭に置いて設定されていない場合があります。 これらのすべての設定不備は機密情報への不正アクセスにつながる可能性があります。</desc>
	<solution>
    * デバッグ機能やQA機能が無効化されていることを確認してください。
    * エラーメッセージが機密情報やデバッグ情報を漏洩させないことを確認してください。
    * 使用している特定のアプリケーション技術スタックのベストプラクティスとセキュリティガイドラインに従ってください。
	</solution>
	<reference>https://cwe.mitre.org/data/definitions/16.html</reference>
</vuln_item_wasc_15>

<vuln_items>wasc_16</vuln_items>
<vuln_item_wasc_16>
	<alert>ディレクトリのインデックシング</alert>
	<desc>自動ディレクトリリスティング/インデックシングは、通常のベースファイル (index.html/home.html/default.htmなど) が存在しない場合に、リクエストされたディレクトリ内のすべてのファイルをリスト表示するWebサーバーの機能です。 ユーザーがWebサイトのメインページをリクエストする場合、通常は https://www.example.com/directory1/ のように、ドメイン名とディレクトリを指定し、特定のファイルは除外してURLを入力します。 Webサーバーはこのリクエストを処理し、ドキュメントルートディレクトリでデフォルトのファイル名を検索し、そのページをクライアントに送信します。 このページが存在しない場合、Webサーバーは動的にディレクトリリストを生成し、その出力をクライアントに送信します。 これは本質的に、そのディレクトリ内で "ls" (Unix) または "dir" (Windows) コマンドを発行し、その結果をHTML形式で表示するのと同じです。 攻撃と対策の観点からは、ソフトウェアの脆弱性と特定のWebリクエストの組み合わせによって、意図しないディレクトリリストが表示される可能性があることを認識することが重要です。</desc>
	<solution>推奨事項には、ドキュメントルートとサーバールートの両方で知る必要性の要件を採用して重要なディレクトリやファイルへのアクセスを制限すること、そして、プライベートファイルを公開し、攻撃者が攻撃を計画または実行する際に利用できる情報を提供する可能性のある自動ディレクトリリスト表示などの機能をオフにすることが含まれます。</solution>
	<reference>https://owasp.org/www-community/attacks/Path_Traversal</reference>
	<reference>https://cwe.mitre.org/data/definitions/548.html</reference>
</vuln_item_wasc_16>

<vuln_items>wasc_17</vuln_items>
<vuln_item_wasc_17>
	<alert>不適切なファイルシステムのパーミッション</alert>
	<desc>不適切なファイルシステムのパーミッションは、Webアプリケーションの機密性、完全性、可用性に対する脅威です。 この問題は、ファイル、フォルダ、およびシンボリックリンクに不正確なファイルシステム権限が設定されたときに発生します。 不適切な権限が設定されると、攻撃者は制限されたファイルやディレクトリにアクセスし、その内容を変更または削除できる可能性があります。 例えば、匿名ユーザーアカウントがファイルへの書き込み権限を持っている場合、攻撃者はファイルの内容を変更してWebアプリケーションに望ましくない影響を与えることができるかもしれません。 また、攻撃者は不適切なシンボリックリンクを悪用して権限を昇格させたり、不正なファイルにアクセスしたりすることもあります。例えば、Webルート外のディレクトリを指すシンボリックリンクなどがこれにあたります。</desc>
	<solution>権限の設定、管理、取り扱いを非常に慎重に行ってください。 明確に、ソフトウェアの信頼範囲を管理してください。</solution>
	<reference>https://owasp.org/www-community/Broken_Access_Control</reference>
	<reference>https://cwe.mitre.org/data/definitions/280.html</reference>
</vuln_item_wasc_17>

<vuln_items>wasc_18</vuln_items>
<vuln_item_wasc_18>
	<alert>認証情報とセッションの予測</alert>
	<desc>認証情報/セッション予測は、Webサイトのユーザーを乗っ取るか、なりすますための手法です。 この攻撃は、特定のセッションやユーザーを識別する一意の値を推測または推量することによって達成されます。 セッションハイジャックとしても知られ、その結果、攻撃者は侵害されたユーザーの権限でWebサイトのリクエストを発行する能力を得る可能性があります。

多くのWebサイトは、最初に通信が確立されたときにユーザーを認証し、追跡するように設計されています。 これを行うために、ユーザーは通常、ユーザー名とパスワード (認証情報) の組み合わせを提供することで、Webサイトに自身の身元を証明する必要があります。 これらの機密の認証情報をトランザクションごとにやり取りする代わりに、Webサイトは認証されたセッションを識別するために一意の「セッションID」を生成します。 その後、ユーザーとWebサイト間の通信には、認証されたセッションの「証明」としてセッションIDがタグ付けされます。 攻撃者が他のユーザーのセッションIDを予測または推測できる場合、不正な活動が可能になります。</desc>
	<solution>ランダムで、一時的で、予測不可能なセッションIDを生成するメカニズムを使用してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html</reference>
	<reference>https://owasp.org/www-community/attacks/Session_Prediction</reference>
</vuln_item_wasc_18>

<vuln_items>wasc_19</vuln_items>
<vuln_item_wasc_19>
	<alert>SQL インジェクション</alert>
	<desc>SQLインジェクションはユーザー提供の入力からSQL文を構築するアプリケーションを悪用するために使用される攻撃手法です。 成功した場合、攻撃者はデータベースに対して実行されるSQL文のロジックを変更することができます。

構造化照会言語 (SQL) はデータベースにクエリを送信するための専門的なプログラミング言語です。 SQLプログラミング言語はANSIおよびISO標準ですが、SQLをサポートする多くのデータベース製品は、標準言語に独自の拡張を加えています。 アプリケーションはSQL文を作成するためにユーザー提供のデータを使用することがよくあります。 アプリケーションがSQL文を適切に構築できない場合、攻撃者が文の構造を変更し、計画外で潜在的に敵対的なコマンドを実行することが可能になります。 そのようなコマンドが実行されると、それらは文を実行するアプリケーションによって指定されたユーザーのコンテキストで実行されます。 この能力により、攻撃者はそのユーザーがアクセスできるすべてのデータベースリソースを制御できるようになり、ホスティングシステム上でコマンドを実行する能力まで含まれる可能性があります。</desc>
	<solution>フェーズ: アーキテクチャおよび設計
この脆弱性が発生しない、またはこの脆弱性を回避しやすくする構造を提供する、実績のあるライブラリやフレームワークを使用してください。
例えば、HibernateやEnterprise Java Beansのような永続化レイヤーの使用を検討してください。これらは適切に使用されれば、SQLインジェクションに対して重要な保護を提供できます。

利用可能であれば、データとコードの分離を自動的に強制する構造化されたメカニズムを使用してください。 これらのメカニズムは、開発者が出力を生成するすべての箇所でこの機能を提供することに頼るのではなく、関連するクォーティング、エンコーディング、および検証を自動的に提供できる場合があります。

プリペアドステートメント、パラメーター化クエリ、またはストアドプロシージャを使用してSQLクエリを処理してください。 これらの機能はパラメーターまたは変数を受け入れ、厳密な型指定をサポートする必要があります。 これらの機能内で "exec" や同様の機能を使用してクエリ文字列を動的に構築・実行しないでください。SQLインジェクションの可能性を再導入する可能性があります。

必要なタスクを達成するために必要な最小限の権限でコードを実行してください。 可能であれば、単一のタスクにのみ使用される限定的な権限を持つ隔離されたアカウントを作成してください。 そうすれば、攻撃が成功しても、攻撃者は直ちにソフトウェアの残りの部分やその環境にアクセスすることはありません。 例えば、データベースアプリケーションが、特に日常業務でデータベース管理者として実行する必要はほとんどありません。

具体的には、SQLデータベースへのユーザーアカウントを作成する際には最小権限の原則に従ってください。 データベースユーザーはアカウントを使用するために必要な最小限の権限のみを持つべきです。 システムの要件がユーザーが自身のデータを読み書きできることを示している場合、他人のデータを読み書きできないように権限を制限してください。 ストアドプロシージャの実行専用権限など、すべてのデータベースオブジェクトに対して可能な限り最も厳しい権限を使用してください。

フェーズ: 実装
リスクにもかかわらず動的に生成されたクエリ文字列やコマンドを使用する必要がある場合は、引数を適切にクォートし、それらの引数内の特殊文字をエスケープしてください。 最も保守的なアプローチは、非常に厳格な許可リスト (英数字や空白以外すべてなど) を通過しないすべての文字をエスケープまたはフィルタリングすることです。 空白などの一部の特殊文字がまだ必要な場合は、エスケープ/フィルタリングステップの後に各引数を引用符で囲んでください。 引数インジェクション (CWE-88) に注意してください。

独自の実装を構築する代わりに、データベースやプログラミング言語でそのような機能が利用できる場合があります。 例えば、Oracle DBMSのASSERTパッケージは、パラメーターがSQLインジェクションに対して脆弱でなくなる特定のプロパティを持つことをチェックまたは強制できます。 MySQLの場合、mysql_real_escape_string() API関数がCとPHPの両方で利用可能です。

すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

SQLクエリ文字列を構築する際には、リクエスト内のパラメーターの期待値に基づいて文字セットを制限する厳格な許可リストを使用してください。 これは間接的に攻撃の範囲を制限しますが、この技術は適切な出力エンコーディングやエスケープほど重要ではありません。

適切な出力エンコーディング、エスケープ、クォーティングがSQLインジェクションを防ぐための最も効果的な解決策であることに注意してください。ただし、入力検証は多層防御を提供する場合があります。 これは、出力に何が現れるかを効果的に制限するためです。 入力検証は常にSQLインジェクションを防ぐわけではありません。特に、任意の文字を含む可能性のある自由形式のテキストフィールドをサポートする必要がある場合はそうです。 例えば、「O'Reilly」という名前は英語圏で一般的な姓であるため、検証ステップを通過する可能性が高いです。 しかし、このデータには「'」のアポストロフィ文字が含まれているため、エスケープまたはその他の処理が必要であり、データベースに直接挿入することはできません。 この場合、アポストロフィを除去することでSQLインジェクションのリスクは軽減される可能性がありますが、間違った名前が記録されるため、不正な動作を引き起こします。

実行可能な場合、メタ文字をエスケープするのではなく、完全に禁止することが最も安全な場合があります。 これにより多層防御が提供されます。 データがデータベースに入力された後、後続の処理でメタ文字の使用前にエスケープを行わない可能性があり、それらの処理を制御できない場合があります。</solution>
	<reference>https://owasp.org/www-community/attacks/SQL_Injection</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html</reference>
</vuln_item_wasc_19>

<vuln_items>wasc_20</vuln_items>
<vuln_item_wasc_20>
	<alert>不適切な入力処理</alert>
	<desc>不適切な入力処理は、今日のアプリケーションで特定される最も一般的な脆弱性の一つです。 不適切に処理された入力はシステムやアプリケーションに存在する重大な脆弱性の主要な原因となります。
	
一般的に、「入力処理」という用語は、入力データの検証、サニタイズ、フィルタリング、エンコーディング、および/またはデコーディングなどの機能を記述するために使用されます。 アプリケーションは、人間のユーザー、ソフトウェアエージェント (ブラウザ)、ネットワーク/周辺機器など、さまざまなソースから入力を受け取ります。 Webアプリケーションの場合、入力はさまざまな形式 (名前と値のペア、JSON、SOAPなど) で転送され、URLクエリ文字列、POSTデータ、HTTPヘッダー、Cookieなどを介して取得できます。 Webアプリケーション以外の入力は、アプリケーション変数、環境変数、レジストリ、設定ファイルなどを介して取得できます。 データの形式や入力のソース/場所に関係なく、すべての入力は信頼できない、潜在的に悪意のあるものと見なされるべきです。 信頼できない入力を処理するアプリケーションは、バッファオーバーフロー、SQLインジェクション、OSコマンド実行、サービス拒否など、数多くの攻撃に対して脆弱になる可能性があります。

入力処理の重要な側面の一つは、入力が特定の基準を満たしていることを検証することです。 適切な検証のためには、アプリケーションが受け入れ、期待するデータの形式と種類を特定することが重要です。 信頼できない入力の各インスタンスの期待される形式と使用法を定義することは、制限を正確に定義するために必要です。 

検証には、型の安全性と正しい構文のチェックが含まれます。 文字列入力は長さ (最小および最大文字数) と文字セットの検証が可能であり、整数や小数などの数値入力タイプは許容される上限値と下限値に対して検証できます。 複数のソースからの入力を組み合わせる場合、検証は個々のデータ要素に対してだけでなく、連結中にも実行されるべきです。 この実践は、個々のデータ項目に対して実行された場合には入力検証が成功するが、すべてのソースからの結合セットに対して行われた場合には失敗するような状況を回避するのに役立ちます。</desc>
	<solution>フェーズ: アーキテクチャおよび設計段階

StrutsやOWASP ESAPI Validation APIなどの入力検証フレームワークを使用してください。

信頼できない入力がソフトウェアに入る可能性のあるすべての領域を理解してください: パラメーターや引数、クッキー、ネットワークから読み取られたもの、環境変数、逆引きDNSルックアップ、クエリ結果、リクエストヘッダー、URLコンポーネント、電子メール、ファイル、データベース、およびアプリケーションにデータを提供する外部システム。 そのような入力は、API呼び出しを介して間接的に取得される可能性があることを忘れないでください。

クライアント側で実行されるセキュリティチェックは、サーバー側でも必ず複製してください。 攻撃者は、チェックが実行された後に値を変更したり、クライアントを変更してクライアント側のチェックを完全に削除したりすることで、クライアント側のチェックをバイパスできます。 その後、これらの変更された値がサーバーに送信されます。

クライアント側のチェックはサーバー側のセキュリティに関して最小限の利点しか提供しませんが、それでも有用です。 第一に、侵入検知をサポートできます。 サーバーがクライアントによって拒否されるべきだった入力を受け取った場合、それは攻撃の兆候である可能性があります。 第二に、クライアント側のエラーチェックは有効な入力の期待値についてユーザーに役立つフィードバックを提供できます。 第三に、偶発的な入力エラーに対するサーバー側の処理時間が短縮される可能性がありますが、これは通常、わずかな節約です。

悪意のある入力を検出したり、出力をエンコードしたりするために、拒否リスト検証のみに依存しないでください。 同じ文字をエンコードする方法は非常に多いため、いくつかのバリアントを見逃す可能性があります。

アプリケーションが複数のソースからのデータを組み合わせる場合は、ソースが結合された後に検証を実行してください。 個々のデータ要素は検証ステップを通過するかもしれませんが、結合された後には意図した制限に違反する可能性があります。

すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

フェーズ: 実装

解釈型言語からネイティブコードへなど、言語の境界を越えるコードを呼び出す際には、入力を特に注意して検証してください。 これにより、言語境界間で予期しない相互作用が生じる可能性があります。 インターフェースしている言語の期待に違反していないことを確認してください。 例えば、Javaはバッファオーバーフローの影響を受けにくいかもしれませんが、ネイティブコードの呼び出しで大きな引数を提供すると、オーバーフローを引き起こす可能性があります。

入力タイプを、文字列を数値に変換する変換関数などを使用して、期待されるデータタイプに直接変換してください。 期待されるデータタイプに変換した後、入力の値が許容値の期待範囲内にあり、複数フィールドの一貫性が維持されていることを確認してください。

入力は、検証される前に、アプリケーションの現在の内部表現にデコードおよび正規化 (canonicalize) されるべきです。 アプリケーションが同じ入力を誤って2回デコードしないようにしてください。 そのようなエラーはチェックされた後に危険な入力を導入することで、許可リストスキームをバイパスするために使用される可能性があります。 OWASP ESAPI Canonicalizationコントロールなどのライブラリを使用してください。

入力が変化しなくなるまで、繰り返し正規化を実行することを検討してください。 これにより、二重デコードなどのシナリオを回避できますが、適切にエンコードされた危険なコンテンツを含むことが許可されている入力を誤って変更する可能性があります。

コンポーネント間でデータを交換する際には、両方のコンポーネントが同じ文字エンコーディングを使用していることを確認してください。 各インターフェースで適切なエンコーディングが適用されていることを確認してください。 プロトコルが許可する限り、使用しているエンコーディングを明示的に設定してください。</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/Improper_Data_Validation</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/89.html</reference>
</vuln_item_wasc_20>

<vuln_items>wasc_21</vuln_items>
<vuln_item_wasc_21>
	<alert>不適切なアンチ自動化</alert>
	<desc>不十分な自動化対策は、Webアプリケーションが元々人間のWebユーザーによって手動でのみ実行されるように設計されたプロセスを、攻撃者が自動化することを許可してしまう場合に発生します。

自動化攻撃の標的となりやすいWebアプリケーションの機能には、以下のようなものがあります：
     * アプリケーションのログインフォーム – 攻撃者はユーザーの認証情報を推測するために、ブルートフォースログインリクエストを自動化する可能性があります。
     * サービス登録フォーム – 攻撃者は自動的に何千もの新しいアカウントを作成する可能性があります。
     * メールフォーム – 攻撃者はメールフォームをスパムリレーや特定のユーザーのメールボックスを溢れさせるために悪用する可能性があります。
     * アカウントメンテナンス – 攻撃者は多数のアカウント無効化または削除リクエストでアプリケーションを溢れさせることにより、アプリケーションに対する大規模なDoSを実行する可能性があります。
     * アカウント情報フォーム – 攻撃者はWebアプリケーションからユーザーの個人情報を収集するために大規模な試行を行う可能性があります。
     * コメントフォーム / コンテンツ投稿フォーム – これらは、スパムやWebベースのマルウェアなどのコンテンツを自動的に投稿することにより、ブログ、Webフォーラム、Web掲示板をスパムするために使用される可能性があります。
     * SQLデータベースクエリに結びついたフォーム - これらはアプリケーションに対してサービス拒否攻撃を実行するために悪用される可能性があります。 これらは、短時間に多数の重いSQLクエリを送信することにより、アプリケーションに対するサービス拒否攻撃を実行するために悪用される可能性があります。これにより、本物のユーザーがサービスを利用できなくなります。
    * eショッピング / eコマース - 人間の買い手のみを強制しないeショッピングやeコマースアプリケーションは、スポーツイベントのチケットなど、人気のアイテムを大量に購入するために悪用される可能性があります。 これらは後で転売ヤ―によって高値で販売されます。
    * オンライン投票 - 投票やその他の種類のオンライン投票システムは、特定の選択肢に有利になるよう不正操作される可能性があります。
    * WebベースのSMSメッセージ送信 - 攻撃者はSMSメッセージ送信システムを悪用して、携帯電話ユーザーにスパムを送信する可能性があります。
	</desc>
	<solution>プロセスの自動化を狙う悪意のある試みから防御するために、強力な自動化対策を実装してください。 以下の戦略を検討してください：
1. **CAPTCHA**: ボットと人間のユーザーを区別するために、重要なフォームにCAPTCHAチャレンジを統合します。
2. **レート制限**: 様々なアクションにレート制限を課し、迅速かつ反復的なリクエストを防ぎ、自動化攻撃の効果を低減させます。
3. **行動分析**: 異常なナビゲーションシーケンスやフォーム送信など、自動化を示すパターンを検出するために、行動分析ツールを実装します。
4. **デバイスフィンガープリンティング**: 疑わしいソースや既知の自動化ツールからのリクエストを特定してブロックするために、デバイスフィンガープリンティングを使用します。
5. **多要素認証 (MFA)**: 多要素認証を導入してセキュリティの層を追加し、自動化攻撃の成功をより困難にします。
6. **ハニーポット**: フォームにハニーポットや隠しフィールドを配置して、自動ボットを騙してその存在を明らかにさせ、適切なアクションを可能にします。
7. **監視とロギング**: ユーザーアクティビティを定期的に監視・記録し、自動化を示す異常なパターンを特定して対応します。

これらの対策を組み合わせることが、自動化攻撃を防ぐ上でより効果的であることが多いです。
</solution>
	<reference>https://owasp.org/www-project-automated-threats-to-web-applications/</reference>
	<reference>https://cwe.mitre.org/data/definitions/116.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/799.html</reference>
</vuln_item_wasc_21>

<vuln_items>wasc_22</vuln_items>
<vuln_item_wasc_22>
	<alert>不適切な出力処理</alert>
	<desc>出力処理とは、アプリケーションが送信データをどのように生成するかを指します。  アプリケーションの出力処理が不適切な場合、出力データが意図しない形で解釈され、アプリケーション開発者が意図しなかった脆弱性やアクションにつながる可能性があります。  多くの場合、この意図しない解釈は1つ以上の重大なアプリケーション脆弱性の形態として分類されます。

データがアプリケーション境界を離れるすべての場所で、不適切な出力処理が発生する可能性があります。  アプリケーション境界は、データがあるコンテキストから別のコンテキストへ移動する場所に存在します。  これには、アプリケーションがWebサービス、ソケット、コマンドライン、環境変数などを介して他のアプリケーションにデータを渡す場合が含まれます。また、データベース、ディレクトリサーバー、HTML/JavaScriptインタープリタ (ブラウザ)、またはオペレーティングシステムなど、アプリケーションアーキテクチャ内の階層間でデータを渡す場合も含まれます。  不適切な出力処理が発生しやすい具体的な場所については、下記の「一般的なデータ出力場所」セクションで詳述します。

不適切な出力処理は、アプリケーション内でさまざまな形で現れる可能性があります。  これらの形式は、プロトコルエラー、アプリケーションエラー、データ消費者関連エラーに分類できます。  プロトコルエラーには、出力エンコーディングやエスケープの欠落または不備、無効なデータの出力が含まれます。  アプリケーションエラーには、不正確なデータの出力や悪意のあるコンテンツをフィルタリングせずに渡すなどのロジックエラーが含まれます。  アプリケーションが正当なコンテンツと不正なコンテンツを適切に区別しない場合、またはデータ消費者の既知の脆弱性を回避しない場合、不適切な出力処理に起因するデータ消費者の乱用につながる可能性があります。

アプリケーションが正しいコンテキストでデータを提供しない場合、攻撃者がデータ消費者を乱用する可能性があります。  これは、コンテンツスプーフィング、クロスサイトスクリプティング、HTTPレスポンス分割、HTTPレスポンススマグリング、LDAPインジェクション、OSコマンド実行、ルーティングデツアー、SOAP配列の乱用、URLリダイレクタ、XMLインジェクション、XQueryインジェクション、XPathインジェクション、メールコマンドインジェクション、ヌルインジェクション、SQLインジェクションなど、WASC脅威分類で参照されている特定の脅威につながる可能性があります。

適切な出力処理は、データ消費者によるデータの予期しないまたは意図しない解釈を防ぎます。  この目的を達成するために、開発者はアプリケーションのデータモデル、データがアプリケーションの他の部分でどのように消費されるか、そして最終的にユーザーにどのように提示されるかを理解する必要があります。  出力の適切な処理を保証するための技術には、データのフィルタリングやサニタイズが含まれますが、これらに限定されません。  しかし、選択された出力処理技術の一貫性のない使用は、出力データが見過ごされたり未処理のままになったりすると、不適切な出力処理のリスクを実際に高める可能性があります。  「多層防御」を確実にするために、開発者は適切な出力処理戦略を選択する際にアプリケーション内のすべてのデータが信頼できないと仮定する必要があります。

適切な出力処理は多くの異なる形をとるかもしれませんが、アプリケーションがデータ消費者による意図しない解釈から保護されない限り、安全であるとは言えません。 この中核的な要件は、アプリケーションが出力操作を安全に処理するために不可欠です。</desc>
	<solution>この弱点を許容しない、または回避を容易にする構造を持つ、検証済みのライブラリやフレームワークを使用してください。

例えば、ESAPIエンコーディングコントロールや同様のツール、ライブラリ、フレームワークの使用を検討してください。 これらは、プログラマがエラーを起こしにくい方法で出力をエンコードするのに役立ちます。

あるいは、組み込み関数を使用しますがそれらの関数に脆弱性が発見された場合に備えてラッパーの使用を検討してください。

利用可能であれば、データとコードの分離を自動的に強制する構造化されたメカニズムを使用してください。 これらのメカニズムは、開発者が出力を生成するすべての箇所でこの機能を提供することに頼るのではなく、関連するクォーティング、エンコーディング、および検証を自動的に提供できる場合があります。

例えば、ストアドプロシージャはデータベースクエリの構造を強制し、SQLインジェクションの可能性を低減できます。

データが使用されるコンテキストと期待されるエンコーディングを理解してください。 これは、異なるコンポーネント間でデータを転送する場合や、Webページやマルチパートメールメッセージのように複数のエンコーディングを同時に含む可能性のある出力を生成する場合に特に重要です。 期待されるすべての通信プロトコルとデータ表現を調査し、必要なエンコーディング戦略を決定してください。

場合によっては、出力エンコーディングが完全な解決策でない場合、入力検証が重要な戦略となることがあります。 例えば、異なるエンコーディングや表現を使用する複数の消費者によって処理される同じ出力を提供している場合があります。 他のケースでは、ウィキや掲示板でのフォーマットをサポートする限定的なHTMLタグなど、ユーザー提供の入力に制御情報を含めることを許可する必要があるかもしれません。 この種の要件を満たす必要がある場合は、どの制御シーケンスが使用できるかを制限するために、非常に厳格な許可リストを使用してください。 結果として得られる構文構造が期待どおりであることを確認してください。 入力の残りの部分には、通常のエンコーディング方法を使用してください。

出力エンコーディングエラーの可能性を低減するための多層防御策として、入力検証を使用してください (CWE-20参照)。

コンポーネント間でデータを交換する際には、両方のコンポーネントが同じ文字エンコーディングを使用していることを確認してください。 各インターフェースで適切なエンコーディングが適用されていることを確認してください。 プロトコルが許可する限り、使用しているエンコーディングを明示的に設定してください。</solution>
	<reference>https://owasp.org/www-project-proactive-controls/v3/en/c4-encode-escape-data</reference>
</vuln_item_wasc_22>

<vuln_items>wasc_23</vuln_items>
<vuln_item_wasc_23>
	<alert>XMLインジェクション</alert>
	<desc>XMLインジェクションは、XMLアプリケーションまたはサービスのロジックを操作または侵害するために使用される攻撃手法です。 意図しないXMLコンテンツおよび/または構造をXMLメッセージに注入することにより、アプリケーションの意図したロジックを変更することができます。 さらに、XMLインジェクションは結果として得られるメッセージ/ドキュメントに悪意のあるコンテンツを挿入する原因となる可能性があります。</desc>
	<solution>ユーザー入力を決して信頼しないでください。 XMLドキュメントに組み込む前に、ユーザー入力を検証およびサニタイズしてください。 XMLメタ文字をブロックまたはエスケープすることを検討してください。例えば、"&lt;" と "&gt;" は、対応するエンティティ "&amp;lt;" と "&amp;gt;" で表現できます。</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</reference>
</vuln_item_wasc_23>

<vuln_items>wasc_24</vuln_items>
<vuln_item_wasc_24>
	<alert>HTTPリクエスト分割</alert>
	<desc>HTTPリクエスト分割は、ブラウザに任意のHTTPリクエストを強制的に送信させ、XSSを引き起こしたりブラウザのキャッシュを汚染したりすることを可能にする攻撃です。 この攻撃の本質は、被害者 (ブラウザ) が攻撃者の悪意のあるHTMLページを読み込まされた後、攻撃者がブラウザの機能の1つを操作して、1つのHTTPリクエストの代わりに2つのHTTPリクエストを送信させる能力にあります。 これまでに、XmlHttpRequest オブジェクト (略してXHR) とHTTPダイジェスト認証メカニズムという2つのメカニズムが悪用されてきました。 この攻撃が成功するには、以下のいずれかの条件が必要です：
* クライアントがHTTPプロキシ経由でアクセスしている (プロキシとサーバー間の解釈差異を悪用)
* 攻撃者と標的ホストが同一IPアドレス上に存在する (ブラウザの同一オリジンポリシーを回避)</desc>
	<solution>CRLFを特別なシーケンスとして使用するのを避けてください。

ユーザーが制御する入力内のCRLFシーケンスを適切にフィルタリングまたはクォートしてください。</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/CRLF_Injection</reference>
	<reference>https://cwe.mitre.org/data/definitions/93.html</reference>
	<reference>https://portswigger.net/web-security/request-smuggling</reference>
</vuln_item_wasc_24>

<vuln_items>wasc_25</vuln_items>
<vuln_item_wasc_25>
	<alert>HTTPレスポンス分割</alert>
	<desc>HTTPレスポンス分割攻撃には、常に少なくとも3つの当事者が関与します：
    * Webサーバー: HTTPレスポンス分割を可能にするセキュリティホールを持つ。
    * ターゲット: おそらく攻撃者に代わってWebサーバーと対話するエンティティ。 通常、これはキャッシュサーバー (フォワード/リバースプロキシ)、またはブラウザ (場合によってはブラウザキャッシュを持つ) です。
    * 攻撃者: 攻撃を開始する。

HTTPレスポンス分割の本質は、攻撃者が単一のHTTPリクエストを送信する能力にあり、これによりWebサーバーは出力ストリームを形成させられます。この出力ストリームは、ターゲットによって、通常の場合の1つのHTTPレスポンスではなく、2つのHTTPレスポンスとして解釈されます。 最初のレスポンスは攻撃者によって部分的に制御されるかもしれませんが、これはそれほど重要ではありません。 重要なのは、攻撃者が2番目のレスポンスの形式をHTTPステータス行からHTTPレスポンスボディの最後のバイトまで完全に制御できることです。 これが可能になると、攻撃者はターゲットを介して2つのリクエストを送信することで攻撃を実現します。 最初のリクエストはWebサーバーから2つのレスポンスを呼び出し、2番目のリクエストは通常、Webサーバー上の何らかの「無害な」リソースに対するものになります。 しかし、2番目のリクエストはターゲットによって、攻撃者が完全に制御する2番目のHTTPレスポンスに一致させられます。 したがって、攻撃者はターゲットを騙し、Webサーバー上の特定のリソース (2番目のリクエストで指定) が、実際には攻撃者がWebサーバーを介して偽造した何らかのデータ (これが2番目のレスポンス) であるにもかかわらず、サーバーのHTTPレスポンス (サーバーのコンテンツ) であると信じ込ませます。

HTTPレスポンス分割攻撃は、サーバースクリプトがHTTPレスポンスヘッダーにユーザーデータを埋め込む場所で発生します。 これは通常、スクリプトがリダイレクションレスポンス (HTTPステータスコード 3xx) のリダイレクトURLにユーザーデータを埋め込む場合や、レスポンスがクッキーを設定する際にスクリプトがクッキーの値や名前にユーザーデータを埋め込む場合に発生します。</desc>
	<solution>検証されていない入力データの使用を避け、HTTPヘッダーを非常に慎重に構築してください。
</solution>
	<reference>https://owasp.org/www-community/attacks/HTTP_Response_Splitting</reference>
	<reference>https://cwe.mitre.org/data/definitions/113.html</reference>
</vuln_item_wasc_25>

<vuln_items>wasc_26</vuln_items>
<vuln_item_wasc_26>
	<alert>HTTPリクエストスマグリング</alert>
	<desc>HTTPリクエストスマグリングは、2つのHTTPデバイス (通常はフロントエンドのプロキシやHTTP対応ファイアウォールと、バックエンドのWebサーバー) 間での、RFCに準拠していないHTTPリクエストの解析の不一致を悪用する攻撃手法です。これにより、リクエストを最初のデバイスを「通して」2番目のデバイスに「密輸 (smuggle)」します。 この技術により、攻撃者は、最初のデバイスが異なるリクエストセットを見ている間に、2番目のデバイスに一連のリクエストを送信することができます。 これにより、部分的なキャッシュ汚染、ファイアウォール保護のバイパス、XSSなど、いくつかの悪用が可能になります。</desc>
	<solution>厳格なHTTP解析手順を採用しているWebサーバー (例: Apache) を使用してください。

SSL通信のみを使用してください。

各リクエストの後にクライアントセッションを終了してください。

すべてのページをキャッシュ不可に設定してください。</solution>
	<reference>https://cwe.mitre.org/data/definitions/444.html</reference>
</vuln_item_wasc_26>

<vuln_items>wasc_27</vuln_items>
<vuln_item_wasc_27>
	<alert>HTTPレスポンススマグリング</alert>
	<desc>HTTPレスポンススマグリングは、サーバーからクライアントへ、単一のレスポンスを期待 (または許可) する中間HTTPデバイスを介して、2つのHTTPレスポンスを「密輸 (smuggl)」する技術です。

この技術の一つの用途は、基本的なHTTPレスポンス分割技術を強化し、アンチHTTPレスポンス分割対策を回避することです。 この場合、中間デバイスはWebサーバーとプロキシサーバー (またはWebブラウザ) の間にあるアンチHTTPレスポンス分割メカニズムです。 もう一つの使用例は、ブラウザが受信するレスポンスを偽装することです。 この場合、悪意のあるWebサイトがブラウザにページを提供し、ブラウザはそのページが別の (標的) ドメインから発信されたものとして解釈します。 ブラウザが両方のサイトにアクセスするためにプロキシサーバーを使用している場合、HTTPレスポンススマグリングを使用してこれを達成できます。

HTTPレスポンススマグリングはHTTPリクエストスマグリングに似た技術を利用して、アンチHTTPレスポンス分割メカニズム (またはプロキシサーバー) がHTTPレスポンスストリームと見なすものと、プロキシサーバー (またはブラウザ) によって解析されるレスポンスストリームとの間の不一致を悪用します。 したがって、アンチHTTPレスポンス分割メカニズムがある特定のレスポンスストリームを無害 (単一のHTTPレスポンス) と見なすかもしれない一方で、プロキシ/ブラウザはそれを依然として2つのHTTPレスポンスとして解析する可能性があり、その結果、元のHTTPレスポンス分割技術のすべての結果 (最初の使用例) に対して脆弱であるか、またはページの偽装 (2番目のケース) に対して脆弱である可能性があります。 例えば、一部のアプリケーションエンジンで使用されているアンチHTTPレスポンス分割メカニズムは、アプリケーションがCR+LFを含むヘッダーをレスポンスに挿入することを禁止しています。 しかし、攻撃者はアプリケーションにCRのみを含むヘッダーを強制的に挿入させ、防御メカニズムを回避することができます。 一部のプロキシサーバーは、依然としてCR (のみ) をヘッダー (およびレスポンス) の区切り文字として扱う可能性があり、そのため、Webサーバーとプロキシサーバーの組み合わせは、プロキシのキャッシュを汚染する可能性のある攻撃に対して依然として脆弱です。
	</desc>
	<solution>バックエンド接続にはHTTP/2を使用する。 HTTP/2はリクエストスマグリングを完全に防ぐわけではありませんが、攻撃者がこの脆弱性を悪用するのを困難にする特定の変更を導入しています。

		異常なリクエスト/レスポンスを検出するための組み込みの緩和策を持つWebアプリケーションファイアウォール (WAF) を利用する。

		HTTPメッセージに Transfer-Encoding と Content-Length の両方が含まれている場合は、Transfer-Encoding ヘッダーを優先するか、HTTPメッセージを完全に拒否する。 この動作をバックエンドサーバーと任意の中間HTTPエージェントで一貫させる。

		以下のような、難読化に使用される不正/無効な Transfer-Encoding ヘッダーを許可しない：
			* 値 "chunked" の前にスペースがないヘッダー
			* 余分なスペースがあるヘッダー
			* 末尾の文字で始まるヘッダー
			* 値 "chunked" の代わりに "chunk" を提供するヘッダー (サーバーはこれをチャンクエンコーディングとして正規化する)
			* 値 "chunked" の前に複数のスペースがあるヘッダー
			* 引用符付きの値 (シングルまたはダブルクォーテーション) を持つヘッダー
			* 値 "chunked" の前にCRLF文字があるヘッダー
			* 無効な文字を持つ値
	</solution>
	<reference>https://owasp.org/www-community/attacks/HTTP_Response_Splitting</reference>
	<reference>https://capec.mitre.org/data/definitions/273.html</reference>
</vuln_item_wasc_27>

<vuln_items>wasc_28</vuln_items>
<vuln_item_wasc_28>
	<alert>Nullバイトインジェクション</alert>
	<desc>NullバイトインジェクションはURLエンコードされたNullバイト文字 (例: %00、または16進数で 0x00) をユーザー提供のデータに追加することで、Webインフラストラクチャのサニティチェックフィルタをバイパスするために使用される能動的な悪用技術です。 このインジェクションプロセスは、アプリケーションの意図したロジックを変更し、悪意のある攻撃者がシステムファイルへの不正アクセスを得ることを可能にする可能性があります。

今日のほとんどのWebアプリケーションは、PHP、ASP、Perl、Javaなどの高水準言語を使用して開発されています。 しかし、これらのWebアプリケーションは、ある時点でシステムレベルで高水準コードを処理する必要があり、このプロセスは通常「C/C++」関数を使用して行われます。 これらの依存技術の多様な性質が「Nullバイトインジェクション」または「Nullバイトポイズニング」攻撃と呼ばれる攻撃クラスを生み出しました。 C/C++では、Nullバイトは文字列の終端点または区切り文字を表し、文字列の処理を直ちに停止することを意味します。 区切り文字に続くバイトは無視されます。 文字列がNull文字を失うと、メモリポインタが次のゼロバイトに遭遇するまで文字列の長さが不明になります。 この意図しない影響は、異常な動作を引き起こし、システムまたはアプリケーションの範囲内に脆弱性を導入する可能性があります。 同様に、いくつかの高水準言語は「Nullバイト」を文字列の長さのプレースホルダーとして扱いますが、そのコンテキストでは特別な意味を持ちません。 この解釈の違いにより、Nullバイトはアプリケーションの動作を操作するために容易に注入される可能性があります。

URLは0x20から0x7E (16進数) または32から126 (10進数) の範囲のUS-ASCII文字セットに制限されています。 しかし、前述の範囲はHTTPプロトコルのコンテキスト内で特別な意味を持つため、許可されていないいくつかの文字を使用します。 このため、拡張ASCII文字表現を使用してURL内に特殊文字を含めるために、URLエンコーディングスキームが導入されました。 「Nullバイト」に関しては、これは16進数で %00 として表現されます。 Nullバイト攻撃の範囲は、Webアプリケーションが基盤となるOSのアクティブな「C」ルーチンや外部APIと対話する場所から始まります。 これにより、攻撃者はアプリケーションのユーザー権限に基づいてファイルを読み書きすることで、Webリソースを操作することができます。</desc>
	<solution>開発者はソフトウェアシステムの入力ベクトルにNull文字またはNullバイトが注入/削除/操作されることを予測すべきです。 ブラックリストとホワイトリストの適切な組み合わせを使用して、有効で、期待され、適切な入力のみがシステムによって処理されるようにする。

すべての入力を悪意のあるものと想定してください。 データを表示または保存する前に、長さ、種類、構文、およびビジネスルールについてすべての入力を検証するために、標準的な入力検証メカニズムを使用する。 「既知の良いものを受け入れる」検証戦略を使用してください。

強力な出力エンコーディング (ISO 8859-1やUTF-8など) を使用し、指定してください。

悪意のある入力を検出したり、出力をエンコードしたりするために、拒否リスト検証のみに依存しないでください。 文字をエンコードする方法には非常に多くのバリアントがあるため、いくつかを見逃す可能性があります。

入力は、検証される前に、アプリケーションの現在の内部表現にデコードおよび正規化 (canonicalize) されるべきです。 アプリケーションが同じ入力を誤って2回デコードしないようにする。 そのようなエラーはチェックされた後に危険な入力を導入することで、許可リストスキームをバイパスするために使用される可能性があります。</solution>
	<reference>https://owasp.org/www-community/attacks/Embedding_Null_Code</reference>
	<reference>https://cwe.mitre.org/data/definitions/158.html</reference>
</vuln_item_wasc_28>

<vuln_items>wasc_29</vuln_items>
<vuln_item_wasc_29>
	<alert>LDAPインジェクション</alert>
	<desc>LDAPインジェクションはユーザー提供の入力からLDAP文を構築するWebサイトを悪用するために使用される攻撃手法です。

ライトウェイトディレクトリアクセスプロトコル (LDAP) は、X.500ディレクトリサービスのクエリと操作の両方を行うためのオープン標準プロトコルです。 LDAPプロトコルはTCPなどのインターネットトランスポートプロトコル上で実行されます。 Webアプリケーションは動的なWebページリクエストのためにカスタムLDAP文を作成するために、ユーザー提供の入力を使用することがあります。

Webアプリケーションがユーザー提供の入力を適切にサニタイズできない場合、攻撃者がLDAP文の構築を変更することが可能になります。 攻撃者がLDAP文を変更できる場合、そのプロセスはコマンドを実行したコンポーネントと同じ権限で実行されます。 (例: データベースサーバー、Webアプリケーションサーバー、Webサーバーなど) これは、権限がLDAPツリー内の何かをクエリ、変更、または削除する権利を付与する場合、深刻なセキュリティ問題を引き起こす可能性があります。 SQLインジェクションで利用可能な同じ高度な悪用技術がLDAPインジェクションにも同様に適用できます。</desc>
	<solution>すべての入力を悪意のあるものと想定してください。 ブラックリストとホワイトリストの適切な組み合わせを使用して、ユーザーが制御する入力からLDAP構文を無害化してください。</solution>
	<reference>https://owasp.org/www-community/attacks/LDAP_Injection</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/90.html</reference>
</vuln_item_wasc_29>

<vuln_items>wasc_30</vuln_items>
<vuln_item_wasc_30>
	<alert>メールコマンドインジェクション</alert>
	<desc>メールコマンドインジェクションは適切にサニタイズされていないユーザー提供の入力からIMAP/SMTP文を構築するメールサーバーやWebメールアプリケーションを悪用するために使用される攻撃手法です。 攻撃者が利用する文の種類に応じて、IMAPインジェクションとSMTPインジェクションの2種類があります。 IMAP/SMTPインジェクションにより、以前はアクセスできなかったメールサーバーにアクセスすることが可能になる場合があります。 場合によっては、これらの内部システムはほとんどのフロントエンドWebサーバーに適用されているようなインフラストラクチャのセキュリティ堅牢化 (ハーデニング) が同レベルではありません。 そのため、攻撃者はメールサーバーが悪用に関してより良い結果をもたらすことを見出すかもしれません。 一方でこの技術は、アプリケーションレベルで存在する可能性のある制限 (CAPTCHA、最大リクエスト数など) を回避することを可能にします。</desc>
	<solution>信頼できない入力がソフトウェアに入る可能性のあるすべての領域を理解してください: パラメーターや引数、クッキー、ネットワークから読み取られたもの、環境変数、リクエストヘッダーおよびコンテンツ、URLコンポーネント、電子メール、ファイル、データベース、およびアプリケーションにデータを提供する外部システム。 明確に定義されたインターフェースで入力検証を実行してください。

すべての入力を悪意のあるものと想定してください。 「既知の良いものを受け入れる」入力検証戦略 (つまり、許可リストを使用) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 予期しない入力を拒否し、潜在的な攻撃を検出するために拒否リストを使用してください。

悪意のある入力を検出したり、出力をエンコードしたりするために、拒否リスト検証のみに依存しないでください。 同じ文字をエンコードする方法は非常に多いため、いくつかのバリアントを見逃す可能性があります。

入力タイプを、文字列を数値に変換する変換関数などを使用して、期待されるデータタイプに直接変換してください。 期待されるデータタイプに変換した後、入力の値が許容値の期待範囲内にあり、複数フィールドの一貫性が維持されていることを確認してください。

入力は、検証される前に、アプリケーションの現在の内部表現にデコードおよび正規化 (canonicalize) されるべきです。 アプリケーションが同じ入力を誤って2回デコードしないようにする。 そのようなエラーはチェックされた後に危険な入力を導入することで、許可リストスキームをバイパスするために使用される可能性があります。 OWASP ESAPI Canonicalizationコントロールなどのライブラリを使用してください。

入力が変化しなくなるまで、繰り返し正規化を実行することを検討してください。 これにより、二重デコードなどのシナリオを回避できますが、適切にエンコードされた危険なコンテンツを含むことが許可されている入力を誤って変更する可能性があります。

コンポーネント間でデータを交換する際には、両方のコンポーネントが同じ文字エンコーディングを使用していることを確認してください。 各インターフェースで適切なエンコーディングが適用されていることを確認してください。 プロトコルが許可する限り、使用しているエンコーディングを明示的に設定してください。

アプリケーションが複数のソースからのデータを組み合わせる場合は、ソースが結合された後に検証を実行してください。 個々のデータ要素は検証ステップを通過するかもしれませんが、結合された後には意図した制限に違反する可能性があります。</solution>
	<reference>https://cwe.mitre.org/data/definitions/88.html</reference>
</vuln_item_wasc_30>

<vuln_items>wasc_31</vuln_items>
<vuln_item_wasc_31>
	<alert>OSコマンドインジェクション</alert>
	<desc>OSコマンドインジェクションはオペレーティングシステムのコマンドを不正に実行するために使用される攻撃手法です。

OSコマンド実行は信頼できるコードと信頼できないデータを混在させた直接的な結果です。 この攻撃は、アプリケーションが信頼できない入力を受け入れて、不適切なデータサニタイズおよび/または外部プログラムの不適切な呼び出しを伴う安全でない方法でオペレーティングシステムのコマンドを構築する場合に可能になります。 OSコマンド実行では、攻撃者によって実行されるコマンドはコマンドを実行したコンポーネント (例: データベースサーバー、Webアプリケーションサーバー、Webサーバー、ラッパー、アプリケーション) と同じ権限で実行されます。 コマンドは実行コンポーネントの権限で実行されるため、攻撃者はこれを利用して、通常は到達できない部分 (例: オペレーティングシステムのディレクトリやファイル) にアクセスしたり、損害を与えたりすることができます。</desc>
	<solution>可能であれば、外部プロセスではなくライブラリコールを使用して、目的の機能を再現してください。

プロセスとオペレーティングシステムの間に厳格な境界を強制する "jail" または同様のサンドボックス環境でコードを実行してください。 これにより、特定のディレクトリでアクセスできるファイルや、ソフトウェアが実行できるコマンドを効果的に制限できます。

OSレベルの例には、Unixのchroot jail、AppArmor、SELinuxがあります。 一般的に、マネージドコードはいくらかの保護を提供できます。 例えば、Java SecurityManager の java.io.FilePermission は、ファイル操作に制限を指定できます。
この手法は実装が困難である可能性があり、オペレーティングシステムへの影響は軽減できても、アプリケーション層での脆弱性は残存する可能性があります。

実行されるコマンドを生成するために使用されるデータについては、そのデータの外部からの制御を可能な限り排除してください。 例えば、Webアプリケーションでは、これを隠しフォームフィールドでクライアントに送信する代わりに、セッションの状態にコマンドをローカルに保存する必要があるかもしれません。

この弱点を許容しない、または回避を容易にする構造を持つ、検証済みのライブラリやフレームワークを使用してください。

例えば、ESAPIエンコーディングコントロールや同様のツール、ライブラリ、フレームワークの使用を検討してください。 これらは、プログラマがエラーを起こしにくい方法で出力をエンコードするのに役立ちます。

リスクにもかかわらず動的に生成されたクエリ文字列やコマンドを使用する必要がある場合は、引数を適切にクォートし、それらの引数内の特殊文字をエスケープしてください。 最も保守的なアプローチは、非常に厳格な許可リスト (英数字や空白以外すべてなど) を通過しないすべての文字をエスケープまたはフィルタリングすることです。 空白などの一部の特殊文字がまだ必要な場合は、エスケープ/フィルタリングステップの後に各引数を引用符で囲んでください。 引数インジェクションに注意。

実行するプログラムが、入力ファイル内または標準入力から引数を指定できる場合は、コマンドラインの代わりにそのモードを使用して引数を渡すことを検討してください。

利用可能であれば、データとコードの分離を自動的に強制する構造化されたメカニズムを使用してください。 これらのメカニズムは、開発者が出力を生成するすべての箇所でこの機能を提供することに頼るのではなく、関連するクォーティング、エンコーディング、および検証を自動的に提供できる場合があります。

一部の言語は、コマンドを呼び出すために使用できる複数の関数を提供しています。 可能な場合、単一の文字列を使用してコマンドシェルを呼び出す関数を特定し、それを個別の引数を必要とする関数に置き換えてください。 これらの関数は通常、引数の適切なクォーティングとフィルタリングを実行します。 例えば、Cでは system() 関数は実行されるコマンド全体を含む文字列を受け入れますが、execl()、execve() などは文字列の配列を必要とします。 Windowsでは、CreateProcess() は一度に一つのコマンドのみを受け入れます。 Perlでは、system() に引数の配列が提供されると、各引数をクォートします。

すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

OSコマンド文字列を構築する際には、リクエスト内のパラメーターの期待値に基づいて文字セットを制限する厳格な許可リストを使用してください。 これは間接的に攻撃の範囲を制限しますが、この技術は適切な出力エンコーディングやエスケープほど重要ではありません。

適切な出力エンコーディング、エスケープ、クォーティングがOSコマンドインジェクションを防ぐための最も効果的な解決策であることに注意してください。ただし、入力検証は多層防御を提供する場合があります。 これは、出力に何が現れるかを効果的に制限するためです。 入力検証は常にOSコマンドインジェクションを防ぐわけではありません。特に、任意の文字を含む可能性のある自由形式のテキストフィールドをサポートする必要がある場合はそうです。 例えば、メールプログラムを呼び出す際、件名フィールドには ";" や ">" 文字などの通常は危険な入力を含める必要がある場合があり、これらはエスケープやその他の処理が必要です。 この場合、文字を除去することでOSコマンドインジェクションのリスクは軽減される可能性がありますが、件名フィールドがユーザーの意図通りに記録されないため、不正な動作を引き起こします。 これは軽微な不便に思えるかもしれませんが、プログラムが他のコンポーネントにメッセージを渡すために適切に構造化された件名行に依存している場合、より重要になる可能性があります。

検証で間違いを犯した場合 (100個の入力フィールドのうち1つを忘れるなど) でも、適切なエンコーディングによりインジェクションベースの攻撃から保護される可能性が高いです。 単独で行われない限り、入力検証は攻撃対象領域を大幅に削減し、一部の攻撃を検出し、適切なエンコーディングでは対処できない他のセキュリティ利益を提供する可能性があるため、依然として有用な技術です。</solution>
	<reference>https://owasp.org/www-community/attacks/Command_Injection</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/78.html</reference>
</vuln_item_wasc_31>

<vuln_items>wasc_32</vuln_items>
<vuln_item_wasc_32>
	<alert>ルーティングデツアー</alert>
	<desc>WS-Routingプロトコル (WS-Routing) は、最初のメッセージ送信者から最終的な受信者まで、通常は一連の中間業者を介してSOAPメッセージを交換するためのプロトコルです。 WS-RoutingプロトコルはSOAP拡張として実装されSOAPヘッダーに埋め込まれます。 WS-RoutingはXMLパスの中間地点でルーティング指示をXMLドキュメントに割り当てることを許可することにより、複雑な環境やトランザクションを通じてXMLトラフィックを誘導する方法を提供するためによく使用されます。

ルーティングデツアーは「中間者攻撃 (Man-in-the-Middle)」の一種であり、中間業者が注入または「ハイジャック」され、機密メッセージを外部の場所にルーティングする可能性があります。 ルーティング情報 (HTTPヘッダーまたはWS-Routingヘッダー内) は途中で変更される可能性があり、ルーティングの痕跡はヘッダーとメッセージから削除されるため、受信側アプリケーションはルーティングデツアーが発生したことに気づきません。 ヘッダーとヘッダーオブジェクトの挿入は、メッセージよりも保護が手薄なことがよくあります。これは、ヘッダーが認証、ルーティング、フォーマット、スキーマ、正規化、名前空間など、トランザクションに関するメタデータの包括的な入れ物として使用されるためです。 また、多くのプロセスがXMLドキュメントのヘッダーへの追加/処理に関与する可能性があります。 多くの実装では、ルーティング情報は、トランザクションの特定のルーティングを提供する外部のWebサービス (例えばWS-Referralを使用) から取得できます。

WS-AddressingはSOAPメッセージにルーティング機能を提供するためにW3Cによって公開された新しい標準です。 WS-RoutingとWS-Addressingの主な違いの1つは、WS-Addressingがルートの次の場所のみを提供することです。 WS-Addressingがルーティングデツアー攻撃に対して脆弱であるかについての研究はほとんど行われていませんが、一部の研究ではWS-Addressingもルーティングデツアーに対して脆弱であることが示唆されています。</desc>
	<solution>あらゆる通信チャネルの両端を常に完全に認証してください。

完全な仲介 (complete mediation) の原則を遵守してください。

証明書は通信相手を認証するために、アイデンティティを暗号鍵にバインドします。 多くの場合、証明書は、対象者のアイデンティティ、公開鍵、および発行日時や有効期限などの情報のハッシュを、発行者の秘密鍵を使用して暗号化した形式をとります。 証明書は発行者の公開鍵で証明書を復号することによって検証できます。 X.509証明書署名チェーンおよびPGP認証構造も参照してください。</solution>
	<reference>https://learn.microsoft.com/en-us/previous-versions/ms951244(v=msdn.10)</reference>
	<reference>https://cwe.mitre.org/data/definitions/300.html</reference>
</vuln_item_wasc_32>

<vuln_items>wasc_33</vuln_items>
<vuln_item_wasc_33>
	<alert>パストラバーサル</alert>
	<desc>パストラバーサル攻撃技術により、攻撃者はWebドキュメントルートディレクトリの外に存在する可能性のあるファイル、ディレクトリ、およびコマンドにアクセスできます。 攻撃者は、Webサイトがサーバー上の任意のファイルのコンテンツを実行または公開するようにURLを操作する可能性があります。 HTTPベースのインターフェースを公開するあらゆるデバイスが、パストラバーサルの脆弱性を持つ可能性があります。

ほとんどのWebサイトはユーザーアクセスを「Webドキュメントルート」または「CGIルート」ディレクトリと呼ばれるファイルシステムの特定の部分に制限します。 これらのディレクトリにはユーザーアクセス用に意図されたファイルと、Webアプリケーションの機能を駆動するために必要な実行可能ファイルが含まれています。 ファイルシステム上の任意の場所でファイルにアクセスしたりコマンドを実行したりするために、パストラバーサル攻撃は特殊文字シーケンスの能力を利用します。

最も基本的なパストラバーサル攻撃は、URLで要求されたリソースの場所を変更するために ../ という特殊文字シーケンスを使用します。 ほとんどの一般的なWebサーバーはこの技術がWebドキュメントルートから脱出するのを防ぎますが、../ シーケンスの代替エンコーディングがセキュリティフィルタをバイパスするのに役立つ場合があります。 これらのメソッドのバリエーションには、スラッシュ文字の有効および無効なUnicodeエンコーディング (..%u2216 または ..%c0%af)、Windowsベースのサーバーでのバックスラッシュ文字 (..\)、URLエンコードされた文字 (%2e%2e%2f)、およびバックスラッシュ文字の二重URLエンコーディング (..%255c) が含まれます。

WebサーバーがURLパス内のパストラバーサル試行を適切に制限している場合でも、Webアプリケーション自体がユーザー提供の入力の不適切な処理のために脆弱である可能性があります。 これは、テンプレートメカニズムを使用したり、ファイルからパッシブテキストを読み込んだりするWebアプリケーションの一般的な問題です。 攻撃のバリエーションでは、元のURLパラメーター値がWebアプリケーションの動的スクリプトのファイル名の1つに置き換えられます。 その結果、ファイルが実行可能なスクリプトではなくテキストとして解釈されるため、ソースコードが明らかになる可能性があります。 これらの技術は、現在の作業ディレクトリのリストを表示するためにドット (.) や、初歩的なファイル拡張子チェックをバイパスするために %00 (Null文字) などの追加の特殊文字をしばしば使用します。</desc>
	<solution>すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

ファイル名については、使用する文字セットを制限する厳格な許可リストを使用してください。 可能であれば、ファイル名には単一の "." 文字のみを許可し、"/" などのディレクトリ区切り文字を除外してください。 許可されるファイル拡張子の許可リストを使用してください。

警告: データをクレンジングしようとする場合、最終結果が危険な形にならないようにしてください。 サニタイズメカニズムは、一部のエクスプロイトに必要な '.' や ';' などの文字を削除する可能性があります。 攻撃者はサニタイズメカニズムを騙してデータを「クリーニング」して危険な形にしようと試みるかもしれません。 入力は検証される前に、アプリケーションの現在の内部表現にデコードおよび正規化 (カノニカライズ) されるべきです。 入力データが安全であると仮定された場合、ファイルが危険にさらされる可能性があります。 

入力は、検証される前に、アプリケーションの現在の内部表現にデコードおよび正規化 (canonicalize) されるべきです。 アプリケーションが同じ入力を誤って2回デコードしないようにする。 そのようなエラーはチェックされた後に危険な入力を導入することで、許可リストスキームをバイパスするために使用される可能性があります。

パス名を正規化バージョン (".." シーケンスやシンボリックリンクを効果的に削除する) を生成する組み込みのパス正規化関数 (Cの realpath() など) を使用してください。

必要なタスクを達成するために必要な最小限の権限でコードを実行してください。 可能であれば、単一のタスクにのみ使用される限定的な権限を持つ隔離されたアカウントを作成してください。 そうすれば、攻撃が成功しても、攻撃者は直ちにソフトウェアの残りの部分やその環境にアクセスすることはありません。 例えば、データベースアプリケーションが、特に日常業務でデータベース管理者として実行する必要はほとんどありません。

ファイル名やURLなど、受け入れ可能なオブジェクトのセットが限定されているか既知である場合、固定の入力値 (数値IDなど) のセットから実際のファイル名やURLへのマッピングを作成し、他のすべての入力を拒否してください。

プロセスとオペレーティングシステムの間に厳格な境界を強制する "jail" または同様のサンドボックス環境でコードを実行してください。 これにより、特定のディレクトリでアクセスできるファイルや、ソフトウェアが実行できるコマンドを効果的に制限できます。

OSレベルの例には、Unixのchroot jail、AppArmor、SELinuxがあります。 一般的に、マネージドコードはいくらかの保護を提供できます。 例えば、Java SecurityManager の java.io.FilePermission は、ファイル操作に制限を指定できます。

この手法は実装が困難である可能性があり、オペレーティングシステムへの影響は軽減できても、アプリケーション層での脆弱性は残存する可能性があります。
</solution>
	<reference>https://owasp.org/www-community/attacks/Path_Traversal</reference>
	<reference>https://cwe.mitre.org/data/definitions/22.html</reference>
</vuln_item_wasc_33>

<vuln_items>wasc_34</vuln_items>
<vuln_item_wasc_34>
	<alert>推測可能なリソース配置</alert>
	<desc>推測可能なリソース配置は隠されたWebサイトのコンテンツや機能を発見するために使用される攻撃手法です。 攻撃者はブルートフォースによって知識に基づいた推測を行うことで、公開を意図していないファイル名やディレクトリ名を推測することができます。 ファイル名やパスはしばしば一般的な命名規則を持ち、標準的な場所に存在するため、ファイル名のブルートフォースは容易です。 これらには、一時ファイル、バックアップファイル、ログ、管理サイトのセクション、設定ファイル、デモアプリケーション、サンプルファイルなどが含まれる可能性があります。 これらのファイルはWebサイト、Webアプリケーションの内部構造、データベース情報、パスワード、マシン名、他の機密領域へのファイルパスなどに関する機密情報を開示する可能性があります。

これは、追加のサイト脆弱性につながる可能性のあるサイトの攻撃対象領域を特定するのに役立つだけでなく、攻撃者に環境やそのユーザーに関する貴重な情報を開示する可能性もあります。 推測可能なリソース配置は強制ブラウジング、強制的ブラウジング、ファイル列挙、ディレクトリ列挙としても知られています。</desc>
	<solution>すべての制限されたURL、スクリプト、またはファイルへの各アクセスに対して、適切なアクセスコントロール認可を適用してください。

StrutsのようなMVCベースのフレームワークの使用を検討してください。</solution>
	<reference>https://owasp.org/www-community/attacks/Forced_browsing</reference>
	<reference>https://cwe.mitre.org/data/definitions/425.html</reference>
</vuln_item_wasc_34>

<vuln_items>wasc_35</vuln_items>
<vuln_item_wasc_35>
	<alert>SOAP配列の不正利用</alert>
	<desc>XML SOAP配列は悪意のある乱用の一般的な標的です。 SOAP配列は "SOAP-ENC:Array" 型またはそこから派生した型を持つものとして定義されます。 SOAP配列は1つ以上の次元 (ランク) を持ち、そのメンバーは順序位置によって区別されます。 配列値は配列を反映する一連の要素として表現され、メンバーは昇順の順序で現れます。 多次元配列の場合、右側の次元が最も速く変化します。 各メンバー要素は独立した要素として名前が付けられます。 配列を期待するWebサービスは、SOAPサーバーにマシンのメモリ内に巨大な配列を構築させることでXML DoS攻撃の標的となり、メモリの事前割り当てによるマシンのDoS状態を引き起こす可能性があります。</desc>
	<solution> 割り当てられるメモリの量に影響を与えるあらゆる値に対して、適切な入力検証を実行してください。 制限を超えるリクエストを処理するための適切な戦略を定義し、必要に応じて管理者が使用するメモリ量を拡張できるように設定オプションをサポートすることを検討してください。

システムが提供するメモリのリソース制限を使用してプログラムを実行してください。 これによりプログラムがクラッシュまたは終了する可能性は依然としてありますが、システムの他の部分への影響は最小限に抑えられます。</solution>
	<reference>https://capec.mitre.org/data/definitions/256.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/789.html</reference>
</vuln_item_wasc_35>

<vuln_items>wasc_36</vuln_items>
<vuln_item_wasc_36>
	<alert>SSIインジェクション</alert>
	<desc>SSIインジェクション (サーバーサイドインクルード) は攻撃者がWebアプリケーションにコードを送信し、それが後でWebサーバーによってローカルで実行されることを可能にするサーバーサイドのエクスプロイト技術です。 SSIインジェクションはWebアプリケーションがユーザー提供のデータを、サーバーサイドで解釈されるHTMLファイルに挿入する前にサニタイズしないという不備を悪用します。

HTMLのWebページを提供する前に、Webサーバーはクライアントに提供する前にサーバーサイドインクルード文を解析して実行することがあります。 場合によっては  (例: メッセージボード、ゲストブック、またはコンテンツ管理システム)、Webアプリケーションはユーザー提供のデータをWebページのソースに挿入します。

攻撃者がサーバーサイドインクルード文を送信した場合、次にページが提供されるときに、任意のオペレーティングシステムコマンドを実行したり、制限されたファイルの内容を含めたりする能力を持つ可能性があります。 これは、Webサーバーユーザーの権限レベルで実行されます。</desc>
	<solution>SSIの実行を必要としないページでは、SSIの実行を無効にしてください。 SSIを必要とするページでは、以下のチェックを実行するようにしてください：
- このページで必要なSSIディレクティブのみを有効にし、その他すべてを無効にします。
- ユーザー提供のデータをHTMLエンティティエンコードしてから、SSI実行権限を持つページに渡します。
- SUExecを使用して、ページがWebサーバーユーザーではなくファイルの所有者として実行されるようにします。</solution>
	<reference>https://owasp.org/www-community/attacks/Server-Side_Includes_(SSI)_Injection</reference>
</vuln_item_wasc_36>

<vuln_items>wasc_37</vuln_items>
<vuln_item_wasc_37>
	<alert>セッション固定化</alert>
	<desc>セッション固定化はユーザーのセッションIDを明示的な値に強制する攻撃手法です。 標的のWebサイトの機能に応じて、セッションIDの値を「固定」するために多くの技術が利用される可能性があります。 これらの技術はクロスサイトスクリプティングのエクスプロイトから、以前に行われたHTTPリクエストでWebサイトを攻撃することまで多岐にわたります。 ユーザーのセッションIDが固定された後、攻撃者はそのユーザーがログインするのを待ちます。 ユーザーがログインすると、攻撃者は事前に定義されたセッションID値を使用して、同じオンラインアイデンティティを乗っ取ります。

一般的に言って、ID値に関してセッション管理システムには2つのタイプがあります。 最初のタイプはWebブラウザが任意のIDを指定することを許可する「寛容な」システムです。 2番目のタイプはサーバーサイドで生成された値のみを受け入れる「厳格な」システムです。 寛容なシステムでは、任意のセッションIDがWebサイトとの接触なしに維持されます。 厳格なシステムでは、攻撃者は非アクティブによるタイムアウトを防ぐために、定期的なWebサイトとの接触で「トラップセッション」を維持する必要があります。

セッション固定化に対する積極的な保護がない場合、攻撃は認証されたユーザーを識別するためにセッションを使用するあらゆるWebサイトに対して仕掛けられる可能性があります。 セッションIDを使用するWebサイトは通常Cookieベースですが、URLや隠しフォームフィールドも使用されます。 残念ながら、Cookieベースのセッションが最も攻撃しやすいです。 現在特定されている攻撃方法のほとんどはCookieの固定化を目的としています。

ユーザーがWebサイトにログインした後にセッションIDを盗むのとは対照的に、セッション固定化ははるかに広い機会の窓を提供します。 攻撃の積極的な部分は、ユーザーがログインする前に行われます。</desc>
	<solution>新しいユーザーセッションを認証する前に、既存のセッションIDを必ず無効化してください。

ASPのように、sessionid Cookieの値を新たに生成しないプラットフォームでは、セカンダリCookie (補助的なCookie) を利用してください。 このアプローチでは、ユーザーのブラウザにセカンダリCookieをランダムな値で設定し、セッション変数にも同じ値を保存します。 もしセッション変数の値とCookieの値が一致しなくなった場合は、そのセッションを無効化し、ユーザーに再ログインを強制してください。</solution>
	<reference>https://owasp.org/www-community/attacks/Session_fixation</reference>
	<reference>https://owasp.org/www-community/controls/Session_Fixation_Protection</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/384.html</reference>
</vuln_item_wasc_37>

<vuln_items>wasc_38</vuln_items>
<vuln_item_wasc_38>
	<alert>URLリダイレクタの不正利用</alert>
	<desc>URLリダイレクタは受信したリクエストを別のリソースへ転送するためにWebサイトで一般的に使用される機能です。 これは様々な理由で行われ、例えばディレクトリ構造内でリソースを移動させた場合に、以前の場所でリソースをリクエストしたユーザーの利便性を損なわないようにするためによく利用されます。 また、URLリダイレクタは負荷分散の実装、URLの短縮、外部リンクの記録などにも使われることがあります。 フィッシング攻撃でしばしば悪用されるのは、この最後の実装例です。 URLリダイレクタ自体は必ずしも直接的なセキュリティ脆弱性ではありませんが、攻撃者がソーシャルエンジニアリングによって被害者を騙し、本来の宛先とは異なるサイトへ誘導するために不正利用される可能性があります。</desc>
	<solution>すべての入力を悪意のあるものと想定してください。 「既知の安全なものを受け入れる (accept known good)」入力検証戦略、つまり、仕様に厳密に準拠する入力の許可リスト (ホワイトリスト) を使用してください。 仕様に厳密に従わない入力は拒否するか、準拠するよう変換してください。 悪意のある、または不正な形式の入力を探すことだけに頼らないでください (すなわち、拒否リスト (ブラックリスト) に頼らないでください)。 ただし、拒否リストは潜在的な攻撃を検出したり、どの入力が非常に不正な形式であるため完全に拒否すべきかを判断したりするのに役立ちます。

入力検証を実行する際は、長さ、入力の種類、許容可能な値の全範囲、入力の欠落または過剰、構文、関連フィールド間の一貫性、およびビジネスルールへの準拠など、すべての潜在的に関連するプロパティを考慮してください。 ビジネスルールのロジックの例として、「boat」は英数字のみを含むため構文的には有効かもしれませんが、「red」や「blue」のような色を期待している場合は有効ではありません。

リダイレクト先として承認されたURLまたはドメインの許可リストを使用する。

ユーザーにサイトから離れることを明確に警告する中間ページ（免責ページ）を表示する。 リダイレクトが発生する前に長いタイムアウトを設定するか、ユーザー自身にリンクをクリックさせるようにしてください。 この中間ページを生成する際には、XSSの問題を回避するよう注意が必要です。

ファイル名やURLなど、受け入れ可能なオブジェクトのセットが限定されているか既知である場合、固定の入力値 (数値IDなど) のセットから実際のファイル名やURLへのマッピングを作成し、他のすべての入力を拒否してください。

例: ID=1 は "/login.asp"、ID=2 は "https://www.example.com/" に対応させる。 ESAPI AccessReferenceMap のような機能がこの能力を提供します。

信頼できない入力がソフトウェアに入る可能性のあるすべての領域を理解してください: パラメーターや引数、クッキー、ネットワークから読み取られたもの、環境変数、逆引きDNSルックアップ、クエリ結果、リクエストヘッダー、URLコンポーネント、電子メール、ファイル、データベース、およびアプリケーションにデータを提供する外部システム。 そのような入力は、API呼び出しを介して間接的に取得される可能性があることを忘れないでください。

プログラマーがクッキーや隠しフォームフィールドなどの特定の入力は改変されないだろうと思い込んでいるため、多くのオープンリダイレクト問題が発生します。あらゆる入力元を信頼しないでください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/601.html</reference>
</vuln_item_wasc_38>

<vuln_items>wasc_39</vuln_items>
<vuln_item_wasc_39>
	<alert>XPathインジェクション</alert>
	<desc>XPathインジェクションは、ユーザーが提供した入力からXPath (XML Path Language) クエリを構築してXMLドキュメントを照会またはナビゲートするアプリケーションを悪用するための攻撃手法です。 この攻撃は、アプリケーションが直接XMLドキュメントを照会する場合や、XSLT変換をXMLドキュメントに適用する、あるいはXQueryをXMLドキュメントに適用するといった、より大きな操作の一部として利用される可能性があります。 XPathの構文はSQLクエリにいくらか似ており、実際にXPathを使用してXMLドキュメントに対してSQLのようなクエリを作成することも可能です。

アプリケーションが実行時にXPathクエリを構築し、安全でないユーザー入力をクエリに埋め込んでいる場合、攻撃者がデータをクエリに注入することで、プログラマの意図とは異なる形で解釈されるクエリを生成させることが可能になります。</desc>
	<solution>ユーザー入力を直接文字列連結せず、XPath変数またはパラメーター化されたXPathクエリを使用してください。 これにより、データプレーン (データ) とコントロールプレーン (命令) の分離が保証されやすくなります。

ユーザー入力の厳格な検証とサニタイゼーションを実施してください。 必要に応じてデータを拒否、フィルタリング、エスケープ処理を行ってください。 XPathクエリで使用される入力が`、その文脈において安全であることを確認してください。</solution>
	<reference>https://owasp.org/www-community/attacks/XPATH_Injection</reference>
	<reference>https://owasp.org/www-community/attacks/Blind_XPath_Injection</reference>
	<reference>https://cwe.mitre.org/data/definitions/643.html</reference>
</vuln_item_wasc_39>

<vuln_items>wasc_40</vuln_items>
<vuln_item_wasc_40>
	<alert>不適切なプロセス検証</alert>
	<desc>不適切なプロセス検証は、Webアプリケーションが攻撃者による意図されたフローやビジネスロジックの迂回を防げない場合に発生します。 実際の攻撃事例では、アクセスコントロールが無効化されたり、金銭的な損失が発生したりする事例が報告されています。

検証が必要なプロセスには、主に2つのタイプがあります: フロー制御とビジネスロジックです。

「フロー制御」とは、ユーザーが各ステップを特定の順序で実行する必要がある、複数ステップのプロセスを指します。 攻撃者がステップを不正にまたは順序を無視して実行すると、アクセスコントロールがバイパスされたり、アプリケーションの整合性にエラーが生じたりする可能性があります。 複数ステップのプロセスの例としては、送金、パスワード回復、購入手続き、アカウント登録などがあります。

「ビジネスロジック」とは、ビジネス上の要件によって定められる、プロセス実行の際のルールや制約を指します。 ビジネスロジックの弱点を悪用するには、そのビジネスに関する知識が必要です。もし知識がなくても悪用できるのであれば、それはおそらくビジネスロジックの欠陥ではありません。 このため、一般的なセキュリティスキャンやコードレビューでは、この種の弱点を見つけることは困難です。 OWASPが提唱するテストアプローチの一つに、OWASP Testing Guideがあります。</desc>
	<solution>複数ステップのプロセス内のすべての操作が、完全に実行されるか、まったく実行されないかのいずれかであることを保証してください。 もし一つのステップが失敗した場合、それまでに行われた変更は取り消されなければならない。 入力のファジングは、異常をテストし、フロー完了後の結果を検証する良い方法です。

フローにおける正しいステップの順序が強制され、ユーザーによってその順序が変更されたりバイパスされたりできないことを保証してください。

開発者とテスターは、アプリケーションが対象とするビジネスドメインを深く理解している必要があります。

ユーザーやアプリケーションの各部分がどのように振る舞うかについて、暗黙の仮定に頼らないでください。

各コンポーネントと相互作用するすべてのコードの呼び出し元を特定し、悪意ある攻撃者がこれらの依存関係を不正に利用した場合に発生する可能性のある問題を評価する。

すべてのトランザクションとワークフローについて、明確なコード、設計書、データフロー図を維持し、各段階で行われた仮定や期待される動作を記録してください。</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability</reference>
	<reference>https://cwe.mitre.org/data/definitions/840.html</reference>
</vuln_item_wasc_40>

<vuln_items>wasc_41</vuln_items>
<vuln_item_wasc_41>
	<alert>XML属性ブローアップ</alert>
	<desc>XML属性ブローアップ (XML Attribute Blowup) はXMLパーサーに対するサービス拒否 (DoS) 攻撃の一種です。 攻撃者は悪意のあるXMLドキュメントを提供し、脆弱なXMLパーサーはそれを非常に非効率的な方法で処理するため、過剰なCPU負荷が発生します。 この攻撃の本質は一つのXMLノードに多数の属性を含めることです。 脆弱なXMLパーサーは属性を非効率的に管理するため (例えば、新しい属性の挿入に O(n) の実行時間がかかるデータコンテナを使用するなど)、全体の実行時間が非線形 (この例では二乗、つまり O(n^2))になり、CPUの枯渇によるサービス拒否状態を引き起こします。</desc>
	<solution>システムのアーキテクチャにスロットリング (流量制限) メカニズムを設計に組み込んでください。 最善の保護策は、認証されていないユーザーが消費させることができるリソースの量を制限することです。 強力な認証およびアクセスコントロールモデルは、そもそもそのような攻撃が発生するのを防ぐのに役立ちます。 ログインアプリケーションは可能な限りDoS攻撃から保護する必要があります。 おそらく結果セットをキャッシュすることによりデータベースアクセスを制限することが、消費されるリソースを最小限に抑えるのに役立ちます。 DoS攻撃の可能性をさらに制限するために、ユーザーから受信したリクエストのレートを追跡し、定義されたレートしきい値を超えるリクエストをブロックすることを検討してください。

リソース枯渇攻撃の緩和には、標的システムが以下のいずれかを行う必要があります：
 * 攻撃を認識し、そのユーザーからのさらなるアクセスを一定時間拒否する。
 * 全リクエストに対する一律制限 (レート制限) により、攻撃者がリソース解放速度を上回る消費を行うことを困難にする。 

最初の解決策は正規ユーザーに対するサービス拒否攻撃を招く可能性があるため、それ自体が問題です。 攻撃者が正規のユーザーIDを使用して意図的に認証を失敗させることで、そのユーザーのアクセスを阻止できるためです。

2番目の解決策は、効果的に実装することが単純に困難であり、適切に実行された場合でも完全な解決策を提供しません。 これは単に、攻撃者がより多くのリソースを必要とするだけです。

各プロトコルレイヤーでスケーラビリティ制限が設けられていることを確認してください。

リソース割り当て失敗時は、システムを安全な状態に移行することを確保してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/400.html</reference>
</vuln_item_wasc_41>

<vuln_items>wasc_42</vuln_items>
<vuln_item_wasc_42>
	<alert>機能の悪用</alert>
	<desc>機能の悪用はWebサイト自身の機能や特徴を利用して、そのサイト自身や他者を攻撃する手法です。 「機能の悪用」とは、アプリケーションが意図した機能を悪用して、望ましくない結果を引き起こすことと定義できます。 これらの攻撃は、リソースの消費、アクセスコントロールの迂回、情報の漏洩など、様々な結果をもたらします。 不正利用の可能性とそのレベルは、Webサイトやアプリケーションによって異なります。 機能の悪用攻撃はしばしば他の攻撃タイプとの組み合わせや、他の攻撃ベクトルを利用して行われます。</desc>
	<solution>APIは常に指定された方法で利用してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Abuse_Case_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/227.html</reference>
</vuln_item_wasc_42>

<vuln_items>wasc_43</vuln_items>
<vuln_item_wasc_43>
	<alert>XML エンティティ参照 (XXE)</alert>
	<desc>このテクニックはXMLの機能を利用して、処理時に動的にドキュメントを構築する点を悪用します。 XMLメッセージは、データを明示的に提供するか、データが存在するURIを指し示すことでデータを提供できます。 この攻撃テクニックでは、外部エンティティがエンティティの値を悪意のあるデータや別の参照先に置き換えたり、サーバーやXMLアプリケーションがアクセスできるデータのセキュリティを侵害したりする可能性があります。
	攻撃者はまた、外部エンティティを利用して、Webサービスサーバーに悪意のあるコードやコンテンツをダウンロードさせ、二次的または連続的な攻撃に利用することもあります。</desc>
	<solution>XML外部実体参照 (XXE) の脆弱性は、アプリケーションのXML解析ライブラリが潜在的に危険なXML機能をサポートしているために発生します。 XXE脆弱性を防ぐには、外部エンティティの解決と XInclude のサポートを無効にしてください。</solution>
	<reference>https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/611.html</reference>
</vuln_item_wasc_43>

<vuln_items>wasc_44</vuln_items>
<vuln_item_wasc_44>
	<alert>XML エンティティ拡張</alert>
	<desc>XML エンティティ拡張 (XML Entity Expansion) 攻撃は、XML DTDの機能を悪用します。この機能は、エンティティと呼ばれるカスタムマクロを作成し、ドキュメント全体で使用できるようにするものです。 攻撃者は、ドキュメントの先頭で一連のカスタムエンティティを再帰的に定義することにより、エンティティを完全に解決しようとするパーサーを圧倒します。これにより、パーサーはこれらの再帰的な定義をほぼ無限に繰り返し処理させられ、過負荷状態に陥ります。

悪意のあるXMLメッセージは、再帰的なエンティティ拡張 (またはその他の反復処理) を強制するために使用され、利用可能なサーバーリソースを完全に使い果たします。</desc>
	<solution>可能であれば、DTDの使用を禁止するか、再帰的なDTDエンティティの展開を制限するXMLパーサーを使用してください。

DTDが関連付けられたXMLファイルを解析する前に、再帰的なエンティティ宣言をスキャンし、爆発的にリソースを消費する可能性のあるコンテンツの解析を続行しないでください。</solution>
	<reference>https://cwe.mitre.org/data/definitions/776.html</reference>
</vuln_item_wasc_44>

<vuln_items>wasc_45</vuln_items>
<vuln_item_wasc_45>
	<alert>フィンガープリンティング</alert>
	<desc>攻撃者にとって最も一般的な手法は、まず標的のウェブ上の存在をフットプリント (情報収集) し、可能な限り多くの情報を列挙することです。 この情報をもとに、攻撃者は標的ホストで使われているソフトウェアの種類やバージョンに存在する脆弱性を効果的に悪用する、具体的な攻撃シナリオを構築できる。

多層フィンガープリンティングは、その前身であるTCP/IPフィンガープリンティング (Nmapのようなスキャナを使用) と似ていますが、トランスポート層ではなくOSIモデルのアプリケーション層に焦点を当てています。 このフィンガープリンティングの背後にある理論は、標的のプラットフォーム、ウェブアプリケーションのソフトウェア技術、バックエンドのデータベースのバージョン、設定、そして場合によってはネットワークアーキテクチャやトポロジーに至るまで、正確なプロファイルを作成することです。</desc>
	<solution>システムのプラットフォーム、ウェブアプリケーションのソフトウェア技術、バックエンドのデータベースのバージョン、設定、ネットワークアーキテクチャに関する情報を難読化または偽装する対策を実装してください。 これには以下が含まれます：

1. **プラットフォームとソフトウェアの多様化**: 攻撃者が正確なプロファイルを作成するのを困難にするため、様々な技術やプラットフォームを組み合わせて使用します。

2. **偽情報の提供**: フィンガープリンティングツールを混乱させるため、システムの応答に偽または誤解を招く情報を導入します。

3. **応答のランダム化**: 攻撃者が一貫してシステムを特定するのを困難にするため、応答内の特定の要素をランダム化します。

4. **ファイアウォールルール**: フィンガープリンティング技術をブロックまたはその効果を制限するためのファイアウォールルールを実装します。

5. **定期的な更新**: ソフトウェア、プラットフォーム、設定を最新の状態に保ち、既知の脆弱性を修正し、古い情報に基づく正確な特定を防ぎます。

万能な解決策はなく、これらの対策を組み合わせることが最も効果的です。</solution>
	<reference>https://cwe.mitre.org/data/definitions/205.html</reference>
</vuln_item_wasc_45>

<vuln_items>wasc_46</vuln_items>
<vuln_item_wasc_46>
	<alert>XQueryインジェクション</alert>
	<desc>XQueryインジェクションは、XML XQuery言語に対する古典的なSQLインジェクション攻撃の変種です。 このインジェクションはXQueryコマンドに渡される不適切に検証されたデータを使用します。 これにより、攻撃者に代わってXQueryルーチンがアクセス可能なコマンドが実行される。 XQueryインジェクションは、被害者の環境上の要素を列挙したり、ローカルホストにコマンドを注入したり、リモートファイルやデータソースに対してクエリを実行するために使用される。 SQLインジェクション攻撃と同様に、攻撃者はアプリケーションのエントリーポイントを通じてリソースアクセス層を標的にします。</desc>
	<solution>パラメーター化クエリの使用。 これにより、データプレーン (データ) とコントロールプレーン (命令) の分離が保証されやすくなります。

ユーザー入力の厳格な検証とサニタイゼーションを実施してください。 必要に応じてデータを拒否、フィルタリング、エスケープ処理を行ってください。 XQLクエリで使用される入力が`、その文脈において安全であることを確認してください。</solution>
	<reference>https://owasp.org/www-community/Injection_Theory</reference>
	<reference>https://owasp.org/www-community/Injection_Flaws</reference>
	<reference>https://cwe.mitre.org/data/definitions/652.html</reference>
</vuln_item_wasc_46>

<vuln_items>wasc_47</vuln_items>
<vuln_item_wasc_47>
	<alert>不適切なセッション有効期限</alert>
	<desc>不適切なセッション有効期限は、Webアプリケーションが攻撃者に対し、古いセッション資格情報やセッションIDの再利用を許可している場合に発生します。 この脆弱性は、ユーザーのセッションIDを盗んだり再利用したりする攻撃に対するWebサイトの脆弱性を高めます。

HTTPはステートレスなプロトコルであるため、Webサイトはリクエスト間でユーザーを一意に識別するために、一般的にCookieを使用してセッションIDを保存します。 したがって、複数のユーザーが同じアカウントにアクセスするのを防ぐために、各セッションIDの機密性を維持する必要があります。 盗まれたセッションIDは、他のユーザーのアカウントを閲覧したり、不正な取引を行ったりするために使用される可能性があります。

セッションの有効期限には、非アクティブタイムアウトと絶対タイムアウトの2種類があります。 絶対タイムアウトは、再認証なしでセッションが有効であり続けられる合計時間として定義され、非アクティブタイムアウトは、セッションが無効になるまでに許容されるアイドル時間です。 適切なセッション有効期限の設定が欠如していると、特定の攻撃の成功率が高まる可能性があります。 長い有効期限は、攻撃者が有効なセッションIDを推測する成功確率を高めます。 有効期限が長いほど、任意の時点で同時に開いているセッションの数が多くなります。 セッションのプールが大きければ大きいほど、攻撃者がランダムに一つを推測する可能性が高くなります。 短いセッション非アクティブタイムアウトは、トークンが直ちに使用される場合には効果がないものの、有効期間中にトークンが盗み取られにくくなるよう保証する役割を果たします。

Webアプリケーションは、事前に定義されたアイドル時間が経過した後にセッションを無効にし (タイムアウト)、ユーザー自身がセッションを無効にする手段 (ログアウト) を提供すべきです。これにより、セッションIDの寿命を可能な限り短く保つことができ、複数の人がコンピュータに物理的に制限なくアクセスできる共有コンピューティング環境では必要不可欠である。 ログアウト機能はユーザーに明確に認識できる位置に配置し、ユーザーのセッションを明示的に無効化し、セッショントークンの再利用を許可しないこと。</desc>
	<solution>セッション/資格情報の有効期限を設定してください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html</reference>
	<reference>https://owasp.org/www-community/Session_Timeout</reference>
	<reference>https://cwe.mitre.org/data/definitions/613.html</reference>
</vuln_item_wasc_47>

<vuln_items>wasc_48</vuln_items>
<vuln_item_wasc_48>
	<alert>安全でないインデックス作成</alert>
	<desc>安全でないインデックス作成は、Webサイトのデータの機密性に対する脅威です。 本来は公開されるべきでないファイルにアクセスできるプロセスによってWebサイトのコンテンツをインデックス化すると、そのようなファイルの存在やその内容に関する情報が漏洩する可能性があります。 インデックス作成プロセスにおいて、このような情報が収集・保存され、後に (簡単ではありませんが) 執念深い攻撃者によって、通常は検索エンジンに対する一連のクエリを通じて取得される可能性があります。 攻撃者は検索エンジンのセキュリティモデルを破るわけではありません。 そのため、この攻撃は巧妙で、検出および阻止することが非常に困難です。攻撃者のクエリを正当なユーザーのクエリと区別するのは容易ではありません。</desc>
	<solution>インデックス作成プロセスを安全にし、機密情報への不正アクセスを防ぐための対策を実装してください。 以下の戦略が考えられます：
1. **アクセスコントロール**: インデックス作成プロセスのアクセス権限を見直し、公開を意図したファイルのみにアクセスしインデックスを作成するように制限する。
2. **ロボット排除規約 (robots.txt)**: robots.txtファイルを使用して、検索エンジンにインデックスを作成させたくないWebサイト領域を明示的に指定します。
3. **認証要件**: 機密ファイルへのアクセスに認証メカニズムを実装し、認証されたユーザーまたはプロセスのみがファイルを取得できるようにします。
4. **ファイル暗号化**: 機密ファイルを暗号化して、不正なユーザーがファイルにアクセスした場合でもその内容を保護します。
5. **URLの編集**: インデックス作成時に公開される可能性のあるURLやファイル名に機密情報を含めないようにします。
6. **セキュリティヘッダ**: セキュリティヘッダ (例: Content Security Policy) を利用して、ブラウザや検索エンジンがWebサイトとどのように対話するかを制御します。

セキュリティに対する積極的かつ多層的なアプローチは、不安全なインデックス化から保護するために極めて重要です。</solution>
	<reference>https://cwe.mitre.org/data/definitions/612.html</reference>
</vuln_item_wasc_48>

<vuln_items>wasc_49</vuln_items>
<vuln_item_wasc_49>
	<alert>不適切なパスワード回復メカニズム</alert>
	<desc>不適切なパスワード回復メカニズムとは、Webサイトが攻撃者に対して、他のユーザーのパスワードを不正に取得、変更、または回復することを許可してしまう状態を指します。 従来のWebサイトの認証方法では、ユーザーはパスワードやパスフレーズを選択し、記憶する必要があります。 パスワードを知っているのはユーザー本人のみであり、正確に記憶しておく必要があります。 時が経過すると、ユーザーのパスワードを記憶する能力は衰えます。 平均的なユーザーがパスワードを要求されるサイトを20も訪問することを考慮すると、この問題はさらに複雑になります。 そのため、パスワード回復はオンラインユーザーにサービスを提供する上で重要な部分です。

自動化されたパスワード回復プロセスの例には、ユーザー登録時に設定した「秘密の質問」に答えることを要求するものがあります。 この質問は、定型質問のリストから選択するか、ユーザーが提供することができます。 もう一つの仕組みとして、ユーザーが登録時にパスワードを思い出せるよう「ヒント」を提供する方法があります。 また、ユーザーの身元を確認するために、社会保障番号、住所、郵便番号などの個人情報の提供を求めるメカニズムもあります。 ユーザーが本人であることを証明した後、回復システムは新しいパスワードを表示またはメールで送信します。

Webサイトが「不十分なパスワード回復メカニズムを持つ」と見なされるのは、攻撃者が使用されている回復メカニズムを打ち破ることができる場合です。 これは、ユーザーの身元を回復のために検証するために必要な情報が、容易に推測可能であるか、または回避可能である場合に起こります。 パスワード回復システムは、ブルートフォース攻撃、システム固有の弱点、または容易に推測できる秘密の質問によって侵害される可能性があります。</desc>
	<solution>パスワード回復メカニズムにユーザーが提供するすべての入力が、徹底的にフィルタリングおよび検証されていることを確認してください。

標準的な弱い秘密の質問を使用せず、複数の秘密の質問を使用してください。

秘密の質問に対する不正解の回数にスロットリング (回数制限) があることを確認してください。 一定 (少数) の不正解の推測の後、パスワード回復機能を無効にしてください。

パスワードをリセットして新しいパスワードを記録上のメールアドレスに送信する前に、ユーザーが秘密の質問に正しく答えることを要求してください。

パスワード回復メカニズムにおいて、新しいパスワードが送信されるメールアドレスをユーザーが制御できないようにしてください。

元のパスワードを明かすのではなく、新しい一時的なパスワードを割り当ててください。</solution>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html</reference>
	<reference>https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html</reference>
	<reference>https://cwe.mitre.org/data/definitions/640.html</reference>
</vuln_item_wasc_49>

</vulnerabilities>
